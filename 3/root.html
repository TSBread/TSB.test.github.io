<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>STM32 &#x5b66;&#x4e60;&#x7b14;&#x8bb0;</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <h1 id="stm32-学习笔记">STM32 学习笔记</h1>
<p><strong>By TSBread</strong></p>
<h2 id="感谢">感谢</h2>
<ul>
<li><a href="https://www.bilibili.com/video/BV1th411z7sn">STM32 入门教程-2023 版 细致讲解 中文字幕 —— <em>@江协科技</em></a></li>
</ul>
<h2 id="gpio-输出">GPIO 输出</h2>
<h3 id="gpio-简介">GPIO 简介</h3>
<p>GPIO（General Purpose Input Output）通用输入输出口</p>
<p>引脚电平：0~3.3v，部分引脚（带 FT 的（Five Tolerate））可容忍<strong>输入</strong>5v</p>
<p><strong>*可配置为 8 中模式：</strong></p>
<ul>
<li>
<p><strong><code>GPIO_Mode_AIN</code>模拟输入</strong>：模拟信号。GPIO 无效，引脚直接接入内部 ADC</p>
</li>
<li>
<p><strong><code>GPIO_Mode_IN_FLOATING</code>浮空输入</strong>：数组信号。可读取引脚电平，若引脚悬空，则电平不确定</p>
</li>
<li>
<p><strong><code>GPIO_Mode_IPD</code>下拉输入</strong>：数字信号。可读取引脚电平，内部连接下拉电阻，悬空时默认低电平</p>
</li>
<li>
<p><strong><code>GPIO_Mode_IPU</code>上拉输入</strong>：数字信号。可读取引脚电平，内部连接上拉电阻，悬空时默认高点平</p>
</li>
<li>
<p><strong><code>GPIO_Mode_OUT_OD</code>开漏输出</strong>：数字信号。可输出引脚电平，高电平为高阻态，低电平接 VSS</p>
</li>
<li>
<p><strong><code>GPIO_Mode_OUT_PP</code>推挽输出</strong>：数字信号。可输出引脚电平，高电平接 VDD，低电平接 VSS</p>
</li>
<li>
<p><strong><code>GPIO_Mode_AF_OD</code>复用开漏输出</strong>：由片上外设控制。高电平为高阻态，低电平接 VSS</p>
</li>
<li>
<p><strong><code>GOIO_Mode_AF_PP</code>复用推挽输出</strong>：由片上外设控制。高电平接 VDD，低电平接 VSS</p>
</li>
</ul>
<h3 id="gpio-基本结构">GPIO 基本结构</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\GPIO_0.png" alt=""></p>
<p><strong>APB2</strong>：APB2 总线，所有 GPIO 都挂载在 APB2 总线上。其中 GPIO 外设名称按照 GPIOA、GPIOB、GPIOC 来命名。每个 GPIO 外设共有 16 个引脚，从 0~15 编号，如 GPIO<em>A</em>的第<em>0</em>号引脚一般称为 P<em>A0</em></p>
<p><strong>GPIO 模块</strong>：每个 GPIO 模块内包含了<strong>寄存器</strong>和<strong>驱动器</strong></p>
<ul>
<li>
<p><strong>寄存器</strong>：使得 CPU 内核可以通过 APB2 总线对其进行读写，以达到输出和读取电平的功能。寄存器的每一位对应一个引脚，输出寄存器写 1 对应引脚输出高电平，反之输出低电平；输入寄存器读取位 1 则对应引脚目前是高电平，反之低电平。<strong>（因为 STM32 为 32 为单片机，所以内部寄存器都是 32 位的，而 GPIO 寄存器只有 16 位，所以仅低 16 位有效）</strong></p>
</li>
<li>
<p><strong>驱动器</strong>：增加信号的驱动能力</p>
</li>
</ul>
<h3 id="gpio-位结构">GPIO 位结构</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\GPIO_1.png" alt=""></p>
<p>从左至右大致分为：寄存器、驱动器、IO 引脚</p>
<p>从上至下大致分为：输入、输出</p>
<p><strong>输入部分：</strong></p>
<p><strong>I/O 引脚</strong>：使用两个保护二极管对输入电压进行钳位，上接 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi>D</mi><mi>D</mi><mo>=</mo><mn>3.3</mn><mi>v</mi></mrow><annotation encoding="application/x-tex">VDD = 3.3v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.02778em;">DD</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3.3</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>，下接 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi>S</mi><mi>S</mi><mo>=</mo><mn>0</mn><mi>v</mi></mrow><annotation encoding="application/x-tex">VSS = 0v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.05764em;">SS</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>。若输入电压 &gt; 3.3v 则上方二极管导通，从而将电流流入 VDD 而不是内部电路，若输入电压 &lt; 0v 则下方二极管导通，从而将电流流入 VSS</p>
<p><strong>上/下拉电阻选择</strong>：该开关可通过程序进行配置，上导通、下断开则为上拉输入模式；下导通、上断开则为下拉输入模式；上下都断开则为浮空输入模式</p>
<p><strong>施密特触发器（文档误译为肖特基触发器）</strong>：对输入电压进行整形，如果输入电压大于某一阈值，输出就会瞬间升为高电平；如果输入电压小于某一阈值，输出就会瞬间降为低电平。输出虽然是数字信号但由于干扰可能会产生各种失真，使用施密特触发器用来防止误判</p>
<p><strong>输入数据寄存器</strong>：将通过<strong>施密特触发器</strong>整形后的波形写入，用程序读取数据寄存器对应的某一位数据便可得知端口的输入电平</p>
<p><strong>至片上外设</strong>：</p>
<ul>
<li>
<p><strong>模拟输入</strong>：未整形波形，输出模拟量。可连接到 ADC 上，因为 ADC 需要接收模拟量</p>
</li>
<li>
<p><strong>复用功能输入</strong>：整形后波形，输出数字量。连接到其他需要读取端口的外设上（如串口的输入引脚等）</p>
</li>
</ul>
<hr>
<p><strong>输出部分：</strong></p>
<p>输出可由<strong>输出数据寄存器</strong>或<strong>片上外设</strong>来进行控制，经过数据选择器到<strong>输出控制</strong>部分</p>
<p><strong>输出数据寄存器</strong>：普通的 IO 口输出，每一位对应着相应的端口。该寄存器同时控制 16 个端口，且只能进行整体的读写（也可以先读取该寄存器，然后使用&amp;=和|=的防止进行更改数据并写回该寄存器以达到控制单独一位的写入）</p>
<p><strong>位设置/清除寄存器</strong>：可以用来单独操作输出数据寄存器的某一位，而不影响其他位。如果要将某一位置 1 则只需将位设置寄存器中对应位写 1 其他写 0 即可，若要置 0 则同理操作位清除寄存器即可</p>
<p><strong>输出驱动器部分</strong>：上为 P-MOS，下为 N-MOS。在此可选择三种输出方式：</p>
<ul>
<li>
<p><strong>推挽</strong>（P-MOS、N-MOS 均有效。数据寄存器为 1 时，上管导通下管断开，高电平；为 0 时，下管导通上管断开，低电平）：在此模式下高低电平均有较强的驱动能力，所以也称为强推输出模式</p>
</li>
<li>
<p><strong>开漏</strong>（仅 N-MOS 有效。数据寄存器为 1 时，下管断开，高阻态；为 0 时，下管导通，低电平）：该模式下仅低电平有驱动能力，高电平无驱动能力。该模式可用作通信协议的驱动方式，如 I2C 通信的引脚便是使用开漏模式，在多机通信的情况下该模式可以避免各个设备的相互干扰；也可用于输出 5v 的电平信号，在 IO 口外接一个上拉电阻到 5v 的电源，当输出低电平时由 N-MOS 直接接到 VSS，当输出高电平时由外 部的上拉电阻拉高至 5v</p>
</li>
<li>
<p><strong>关闭</strong>（均无效）：当引脚被配置为输入模式时使用该模式，端口的电平由外部信号来控制</p>
</li>
</ul>
<p><strong>*注意：</strong> 一个端口只能有一个输出，但可以有多个输入（输入模式下输出均无效，但输出模式下仍然可以进行输入）</p>
<h3 id="实操">实操</h3>
<p>根据上述所得，操作 STM32 的 GPIO 总共需要 3 个步骤：</p>
<ol>
<li>
<p><strong><a href="./funcs.html#stm32f10x_rcc">使用 RCC（复位和时钟控制）</a>开启 GPIO 的时钟</strong></p>
</li>
<li>
<p><strong><a href="./funcs.html#stm32f10x_gpio">使用<code>GPIO_Init</code>函数</a>初始化 GPIO</strong></p>
</li>
<li>
<p><strong>使用输出或输入的函数控制 GPIO</strong></p>
</li>
</ol>
<h2 id="exti-外部中断">EXTI 外部中断</h2>
<h3 id="中断系统">中断系统</h3>
<p><strong>中断</strong>：在主程序运行过程中，出现了特定的中后段触发条件（中断源），使得 CPU 暂停当前正在运行的程序，转而去处理中断程序，处理完成后又返回原来被暂停的位置继续运行。使用中断可大大提高程序运行效率 <em>（如串口数据发送，避免了为了防止数据被覆盖从而使得主程序不断查询是否有串口数据发送的事件被触发导致无法继续运行；若没有定时器中断那主程序只能依靠堵塞的 Delay 来实现定时的功能）</em></p>
<p><strong>中断优先级</strong>：功能类似裁决器，当多个中断源同时申请中断时，CPU 根据中断源的轻重缓急进行裁决，优先相应更加紧急的中断源</p>
<p><strong>中断嵌套</strong>：当一个中断程序正在运行时，又有新的更高优先级的中断源申请中断，CPU 将会中断当前的中断程序转而去处理新的更高级别的中断程序，处理完后再依次返回</p>
<h3 id="stm32-中断">STM32 中断</h3>
<p><strong>中断向量表</strong>：</p>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\EXTI_0.png" alt=""></p>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\EXTI_0_1.png" alt=""></p>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\EXTI_0_2.png" alt=""></p>
<p>STM32 中断通道都包括：EXTI（外部中断）、TIM（定时器）、ADC（模数转化器）、USART（串口）、SPI、I2C、RTC（实体时钟）等多个外设</p>
<p>使用<strong>NVIC</strong>统一管理中断：每个中断都拥有 16 个可编程的右胸按等级，可对优先级进行分组，进一步设置<strong>抢占优先级</strong>和<strong>响应优先级</strong>。<strong>NVIC</strong>是 STM32 用来管理中断、分配优先级的</p>
<p>本节中（EXTI 外部中断）仅讨论上图中的中断资源为：EXTI0~4、EXTI9_5、EXTI15_10</p>
<blockquote>
<p><strong>中断地址</strong>：因为程序中的中断函数的地址是由编译器分配的，并非固定的。但中断跳转由于硬件限制只能跳转到固定的地址执行程序，所以将跳转到中断函数的代码写入固定的内存地址，从而当中断发生后跳转入固定的中断地址后再跳转进对应的中断函数处</p>
</blockquote>
<h3 id="nvic-基本结构">NVIC 基本结构</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\EXTI_1.png" alt=""></p>
<p>NVIC 嵌套中断向量控制器：将所有中断接收并按优先级排序后传给 CPU</p>
<h3 id="nvic-优先级分组">NVIC 优先级分组</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\EXTI_2.png" alt=""></p>
<p>NVIC 的中断优先级由优先级寄存器的 4 位（0~15）决定，这 4 位可以进行切分，分为高 n 位的抢占优先级和低 4-n 位的响应优先级。</p>
<p>响应优先级和抢占优先级均相同的中断按照<strong>中断向量表</strong>的**中断号（优先级）**进行排序</p>
<p><strong>响应优先级</strong>：当前一个中断处理完后，优先处理响应优先级高的中断</p>
<p><strong>抢占优先级</strong>：即使前一个中断未处理完，也要优先处理抢占优先级高的中断直到该中断处理完</p>
<h3 id="exti-简介">EXTI 简介</h3>
<p>EXTI（Extern Interrupt）外部中断</p>
<p>EXTI 可以检测指定 GPIO 口的电平信号，当其指定的 GPIO 口产生电平变化时，EXTI 将立即向 NVIC 发出中断申请，经过 NVIC 裁决后即可中断 CPU 主程序，使 CPU 执行 EXTI 对应的中断程序</p>
<p><strong>支持的触发方式</strong>：上升沿 / 下降沿 / 双边沿 / 软件触发</p>
<p>EXTI 中断支持所有的 GPIO 口，但<strong>相同的 Pin 不能同时触发中断（如 PA0 和 PB0 不能同时使用）</strong></p>
<p>通道数：16 个 GPIO 的 Pin、<em>PVD 输出、RTC 闹钟、USB 唤醒、以太网唤醒</em></p>
<p><strong>触发响应方式</strong>：<strong>中断响应</strong>（向 NVIC 申请中断） / <strong>事件响应</strong>（当电平引脚发生变化时可以选择直接触发中断或是触发事件，若触发事件则中断信号不会传给 CPU，而是传给其他外设，用来触发其他外设的操作（如 ADC 转换、触发 DMA 等））</p>
<h3 id="exti-基本结构">EXTI 基本结构</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\EXTI_3.png" alt=""></p>
<p><strong>AFIO</strong>：中断引脚选择。本质是一个数据选择器，因为 EXTI 只有 16 个 GPIO_Pin 通道所以进行筛选。AFIO 会在每个 GPIO 中选择一个连接到 EXTI 中，也因此相同的 Pin 不能同时触发中断（对于 PA0、PB0、PC0 这些 Pin，在通过 AFIO 选择后只有其中一个能连接到 EXTI 的通道 0 上，其他 Pin 同理）</p>
<p><strong>EXTI -&gt; NVIC</strong>：EXTI 总共输入 20 个通道，但传入 NVIC 的外部中断 5~9 和 10~15 合并为<code>EXTI9_5</code>、<code>EXTI15_10</code>。也就是说被包含的外部中断被触发时都会触发同一个中断函数，需要再在该中断函数中通过标志位来区分具体是哪个通道触发的中断</p>
<p><strong>EXTI -&gt; 其他外设</strong>：用来触发其他外设操作的，也就是上小节（#EXTI 简介）提到的<strong>事件响应</strong></p>
<h3 id="afio-复用-io-口">AFIO 复用 IO 口</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\EXTI_4.png" alt=""></p>
<p>AFIO 主要用于引脚复用功能的选择和重定义（数据选择器的作用）</p>
<p>在 STM32 中 AFIO 起到了两个作用：<strong>复用引脚重映射</strong>（也就是引脚映射表中的<code>复用功能</code>转换为<code>重定义功能</code>）、中断引脚选择</p>
<p><strong>使用数据选择器在同号的 Pin 中选择其中一个的 GPIO 并传给 EXTI，因此不能选择同号 Pin 触发外部中断</strong></p>
<h3 id="exti-框图">EXTI 框图</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\EXTI_5.png" alt=""></p>
<p>*以一路通道为例：</p>
<p><code>AFIO -&gt; 输入线 -&gt; 边沿检测</code>：根据检测结果与<strong>触发方式</strong>决定是触发上升沿还是下降沿还是二者都触发</p>
<p><code>边沿检测 -&gt; 或门</code>：硬件触发与软件中断寄存器接到同一个或门上，若任意一值为 1 则输出 1。此处软件中断寄存器为软件触发位置</p>
<p><code>或门 -&gt;</code>：上路触发中断，下路触发事件。</p>
<ul>
<li>
<p><code>触发中断</code>：触发后会先置一个挂起寄存器，相当于中断的标志位。通过读取<code>请求挂起寄存器</code>的值来判断哪个通道触发了中断。在此路中<code>中断屏蔽寄存器</code>和一个与门组成一个类似开关的功能来决定是否将挂起寄存器的输出发送到 NVIC</p>
</li>
<li>
<p><code>触发事件</code>：在此路中<code>事件屏蔽寄存器</code>和一个与门组成 一个类似开关的功能来决定是否将信号继续发送到其他外设。</p>
<ul>
<li><code>脉冲发生器</code>：输出一个电平脉冲，用来触发其他外设的</li>
</ul>
</li>
</ul>
<h3 id="实操-1">实操</h3>
<p>根据上述所得，使用外设作为 EXTI 外部中断并执行程序总共需要 5 个步骤：</p>
<ol>
<li>配置 RCC，将设计的外设时钟打开</li>
<li>配置 GPIO，选择端口为输入模式</li>
<li>配置 AFIO，选择对应 GPIO 和 Pin，连接到 EXTI</li>
<li>配置 EXTI，选择触发模式（此处是使用外设信号作为触发源则使用边沿触发方式）、触发响应方式（此处使用中断响应，因为是要执行程序）</li>
<li>配置 NVIC，给该中断选择一个适合的优先级</li>
</ol>
<h2 id="tim-定时中断">TIM 定时中断</h2>
<h3 id="tim-简介">TIM 简介</h3>
<p>TIM（Timer）定时器</p>
<p>最基本的功能：定时器可以对输入的时钟（可靠的基准时钟，STM32 中使用主频 72MHz 的时钟）进行计数（也就是个计数器），并在计数值达到设定值时触发中断。如对 72MHz 计 72 个数也就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>M</mi><mi>H</mi><mi>z</mi><mo>=</mo><mn>1</mn><mi>u</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">1MHz = 1us</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal" style="margin-right:0.04398em;">Hz</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span></span></span></span>；计 72000 个数也就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>K</mi><mi>H</mi><mi>z</mi><mo>=</mo><mn>1</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">1KHz = 1ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.04398em;">KHz</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></p>
<p>STM32 的定时器拥有：<strong>16 位计数器</strong>（用来执行计数定时的一个寄存器，每来一个时钟，计数器 + 1）、<strong>预分频器</strong>（对计数器的时钟进行分频，使得计数更加灵活）、<strong>自动重装寄存器</strong>（计数的目标值，要在多少个时钟时申请中断），这部分电路被称为<strong>时基单元</strong>，在 72MHz 计数时钟下可以实现最大 59.65s 的定时。</p>
<blockquote>
<p>因以上三种寄存器均为 16 位，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>1</mn></msup><mn>6</mn><mo>=</mo><mn>65536</mn></mrow><annotation encoding="application/x-tex">2 ^ 16 = 65536</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">65536</span></span></span></span>，若预分频器和自动重装都设定到最大，那定时器的最大定时时间就是 59.65s（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>72</mn><mi>M</mi><mi mathvariant="normal">/</mi><mn>65536</mn><mi mathvariant="normal">/</mi><mn>65536</mn><mo>=</mo><mtext>中断频率</mtext></mrow><annotation encoding="application/x-tex">72M / 65536 / 65536 = 中断频率</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">72</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord">/65536/65536</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">中断频率</span></span></span></span>，取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mtext>中断频率</mtext><mo>=</mo><mn>59.65</mn></mrow><annotation encoding="application/x-tex">1 / 中断频率 = 59.65</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1/</span><span class="mord cjk_fallback">中断频率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">59.65</span></span></span></span>）</p>
<blockquote>
<p>STM32 的定时器支持级联模式（用一个定时器的输出当作另一个定时器的输入），若两个定时器级联，最大定时时间就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>59.65</mn><mi>s</mi><mo>∗</mo><mn>65536</mn><mo>∗</mo><mn>65536</mn></mrow><annotation encoding="application/x-tex">59.65s * 65536 * 65536</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">59.65</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">65536</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">65536</span></span></span></span></p>
</blockquote>
</blockquote>
<p>STM32 的定时器不仅具备基本的<code>定时中断</code>功能，还包括<code>内外时钟源选择</code>、<code>输入捕获</code>、<code>输出比较</code>、<code>编码器接口</code>、<code>主从触发模式</code>等多种功能</p>
<h3 id="定时器类型">定时器类型</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\TIM_0.png" alt=""></p>
<p><strong>计数器模式</strong>：</p>
<ul>
<li>
<p><strong>向上计数模式</strong>（基础定时器）：从 0 开始自增计数直到达到目标值，然后清零同时申请中断</p>
</li>
<li>
<p><strong>向上计数模式</strong>（基础定时器、通用定时器、高级定时器）：从目标值开始自减计数直到达到 0，然后重装同时申请中断</p>
</li>
<li>
<p><strong>中央对其模式</strong>（基础定时器、通用定时器、高级定时器）：从 0 开始自增到目标值，然后申请中断，再继续向下自减到 0，再次申请中断，依次循环</p>
</li>
</ul>
<h3 id="基本定时器">基本定时器</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\TIM_1.png" alt=""></p>
<p>从下往上看：<strong>预分频器</strong>、<strong>计数器</strong>、<strong>自动重装寄存器</strong>三者构成了最基本的计数计时电路，也被称为时基单元</p>
<p><strong>PSC 预分频器</strong>：对 72MHz 的计数时钟进行预分频，= 0 -&gt; 不分频（也就是 1 分频。此时输出频率 = 输入频率 = 72MHz），= 1 -&gt; 2 分频（输出频率 = 输入频率 / 2 = 36MHz），= 2 -&gt; 3 分频，以此类推 <strong>（实际分频系数 = 预分频器值 + 1.因预分频器是 16 位的，也就是可以写 65535，实际分频系数 = 65535 + 1 = 65536 分频）</strong>。<code>CK_PSC</code>连接基准计数时钟的输入。由于基本定时器只能选择内部时钟，所以<code>CK_PSC</code>直接连接到输入端（内部时钟<code>CK_INT</code>），内部时钟的来源是<code>RCC_TIMxCLK</code>，频率值一般都是系统的主频 72MHz</p>
<p><strong>CNT 计数器</strong>：对预分频后的计数时钟进行计数，计数时钟每来一个上升沿，计数器的值就 + 1（<strong>向上计数模式</strong>）。计数器也是 16 位，可以从 0 加到 65535，再加则会从 0 重新开始</p>
<p><strong>ARR 自动重装载寄存器</strong>：存储写入的计数目标，同为 16 位寄存器。当计数器值到达目标值时产生中断信号并清零计数器。</p>
<ul>
<li>
<p><code>UI</code>表示会产生中断信号（这种计数值等于自动重装值产生的中断被称为<strong>更新中断</strong>），中断产生后通向<strong>NVIC</strong></p>
</li>
<li>
<p><code>U</code>表示会产生一个事件（被称为<strong>更新事件</strong>），不会触发中断，但可以触发内部其他电路工作</p>
</li>
</ul>
<h3 id="通用定时器">通用定时器</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\TIM_2.png" alt=""></p>
<p>中间为<strong>时基单元</strong>，结构与基础定时器相同</p>
<ul>
<li><strong>CNT 计数器</strong>：与基础定时器的计数器不同的是，通用定时器和高级定时器还支持<strong>向下计数模式</strong>和<strong>中央对其模式</strong></li>
</ul>
<p>上面为<strong>内外时钟源选择</strong>和<strong>主从触发模式</strong>的结构</p>
<ul>
<li>
<p><strong>内外时钟源选择</strong>：时钟源不仅可以选择内部的 72MHz 时钟（<code>CK_INT</code>）还可以选择外部时钟</p>
<ul>
<li>
<p><code>TIMx_ETR</code>引脚上的外部时钟，需要配置<code>TIMx_ETR -ETR-&gt; 极性选择、边沿检测和预分频器 -ETRP-&gt; 输入滤波 -ETRF-&gt; CK_PSC</code>，这一路也叫做<strong>外部时钟模式 2</strong></p>
</li>
<li>
<p><code>TRGI</code>触发输入，可以触发定时器的从模式。可当作外部时钟来使用，该路被称为<strong>外部时钟模式 1</strong>。该模式下可通过的外部时钟有：</p>
<ul>
<li>
<p><code>ETR</code>：引脚信号（可通过上路来当作时钟，也可通过下路到数据选择器来当时钟。二者等价，但下路输出会占用触发输入的通道）</p>
</li>
<li>
<p><code>ITR</code>：来自其他定时器的时钟信号（主模式的输出 TRGO 可以通向其他定时器，连接到其他定时器的 ITR 引脚（实现<strong>定时器级联</strong>的功能））</p>
<p>从定时器的<code>ITRx</code>与主定时器的<code>TRGO</code>连接方式见下图 👇</p>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\TIM_4.png" alt=""></p>
<p>例如：我要实现两个定时器级联的模式，先初始化 TIM3，使用主模式将更新事件映射到其<code>TRGO</code>上，再初始化 TIM2，对应 TIM3<code>TRGO</code>的是<code>ITR2</code>，接着选择时钟为<strong>外部时钟模式 1</strong>。这样 TIM3 的更新事件就可以驱动 TIM2 的时基单元，也就完成了两个定时器的级联功能</p>
</li>
<li>
<p><code>TI1F_ED</code>：连接着输入捕获单元的 CH1 引脚，也就是从<code>TIMx_CH1</code>获取时钟，<code>ED</code>（Edge）的含义为<strong>边沿</strong>，也就是通过该路输入的时钟，上升沿和下降沿均有效</p>
</li>
<li>
<p><code>TI1FP1</code>：连接到 CH1 引脚的时钟</p>
</li>
<li>
<p><code>TI2FP2</code>：连接到 CH2 引脚的时钟</p>
</li>
</ul>
</li>
<li>
<p><code>TRGO</code>：定时器的主模式输出，可以把内部的一些事件映射到<code>TRGO</code>引脚上，用于触发其他定时器、DAC、ADC</p>
</li>
</ul>
</li>
</ul>
<p>右下角为<strong>输出比较（OC）电路</strong>，总共 4 个通道（CH1~4），用于输出 PWM 波形，驱动电机</p>
<p>左下角为<strong>输入捕获（IC）电路</strong>，总共 4 个通道（CH1~4），用于测量方波的频率等</p>
<p>下面中间为<strong>捕获/比较寄存器</strong>，是输入捕获和输出比较电路共用的。因为输出比较和输入捕获不能同时使用，所以该寄存器是共用的，包括引脚</p>
<h3 id="高级定时器">高级定时器</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\TIM_3.png" alt=""></p>
<p>相比通用定时器而言，主要改动的是右下和左下部分</p>
<p><strong>重复次数计数器</strong>：在申请中断的地方新增，可以实现每隔几个计数周期才会发生一次更新事件和更新中断。相当于对原本的中断信号再进行一次分频</p>
<p><strong>输出比较模块</strong>：</p>
<ul>
<li>
<p><code>DTG和输出比较电路</code>：（Dead Time Generate）死区生成电路，右边输出引脚由原本的一路输出变成两路互补的输出。此处一般用作驱动三相无刷电机所以仅 CH1~3 有该互补输出功能</p>
</li>
<li>
<p><code>TIMx_BKIN</code>：刹车输入功能，给电机驱动提供安全保障。当刹车引脚产生信号或内部时钟失效，控制电路会自动切断电机的输出</p>
</li>
</ul>
<h3 id="定时中断基本结构">定时中断基本结构</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\TIM_5.png" alt=""></p>
<p><strong>*此图中高低定时器的重复次数计数器未画出，应在时基单元输出到中断控制之间</strong></p>
<h3 id="预分频器时序">预分频器时序</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\TIM_6.png" alt=""></p>
<p><code>CK_PSC</code>：预分频器的输入时钟，内部时钟为 72MHz</p>
<p><code>CNT_EN</code>：计数器使能，高电平计数器运行，低电平计数器停止</p>
<p><code>CK_CNT</code>：计数器时钟，既是预分频器的输出也是计数器的输入。计数器未使能时计数器时钟不运行，使能后前半段等于预分频器前的时钟，后半段二分频变为前时钟的一半</p>
<p><code>计数器寄存器</code>：跟随时钟的上升沿不断自增，在 FC 后变为 0，由此可退出 ARR 自动重装值为 FC</p>
<p><code>更新事件（UEV）</code>：当达到重装值后产生一个脉冲</p>
<p><code>预分频缓冲器</code>：为预分频控制寄存器的影子寄存器，用户读写预分频控制寄存器，但实际控制分频的为该寄存器。（结构图中带黑色阴影的寄存器都含有一个影子寄存器）</p>
<p><strong>*计数器计数频率：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><msub><mi>K</mi><mi>C</mi></msub><mi>N</mi><mi>T</mi><mo>=</mo><mi>C</mi><msub><mi>K</mi><mi>P</mi></msub><mi>S</mi><mi>C</mi><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>P</mi><mi>S</mi><mi>C</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">CK_CNT = CK_PSC / (PSC + 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">NT</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.07153em;">SC</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">PSC</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></strong></p>
<h3 id="计数器时序">计数器时序</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\TIM_7.png" alt=""></p>
<p><code>CK_INT</code>：内部时钟 72MHZ</p>
<p><code>CNT_EN</code>：时钟使能，高电平开启</p>
<p><code>CK_CNT</code>：计数器时钟，因为分频系数为 2 所以该频率为<code>CK_INT</code> / 2</p>
<p><code>计数器寄存器</code>：在每个<code>CK_CNT</code>的上升沿自增。</p>
<p><code>计数器溢出</code>：当计数到 0036 时溢出，到下一个上升沿清零</p>
<p><code>更新事件（UEV）</code>：当计数器溢出时产生一个脉冲</p>
<p><code>更新中断标志（UIF）</code>：当计数器溢出时置 1，只要为 1 就会申请中断，中断响应后需要在中断程序中手动清零，否则会一直申请中断</p>
<p><strong>*计数器溢出频率：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><msub><mi>K</mi><mi>C</mi></msub><mi>N</mi><msub><mi>T</mi><mi>O</mi></msub><mi>V</mi><mo>=</mo><mi>C</mi><msub><mi>K</mi><mi>C</mi></msub><mi>N</mi><mi>T</mi><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>A</mi><mi>R</mi><mi>R</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>C</mi><msub><mi>K</mi><mi>P</mi></msub><mi>S</mi><mi>C</mi><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>P</mi><mi>S</mi><mi>C</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>A</mi><mi>R</mi><mi>R</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">CK_CNT_OV = CK_CNT / (ARR + 1) = CK_PSC / (PSC + 1) / (ARR + 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">NT</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.00773em;">RR</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.07153em;">SC</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">PSC</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.00773em;">RR</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></strong></p>
<h3 id="计数器无预装时序">计数器无预装时序</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\TIM_8.png" alt=""></p>
<p><strong>*在此之前上面两个都是含有缓冲寄存器（影子寄存器）的情况，该时序为没有缓冲寄存器的时序情况</strong></p>
<p>在计数的中途将<code>自动加载寄存器</code>的值从 FF 改为 36，<code>计数器寄存器</code>的值将直接在到达 36 时产生更新事件</p>
<h3 id="计数器有预装时序">计数器有预装时序</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\TIM_9.png" alt=""></p>
<p>在计数的中途将<code>自动加载寄存器</code>的值从 F5 改为 36，因真正起作用的是<code>影子寄存器</code>，所以当前计数目标仍旧是 F5，直到达到 F5 产生更新事件才会将自动重装值改为 36</p>
<p>影子寄存器的作用就是为了让值的变化和更新事件保持同步，防止在运行途中更改从而造成错误</p>
<h3 id="实操-2">实操</h3>
<p>根据上述所得，使用内部时钟进行定时中断总共需要 6 个步骤：</p>
<ol>
<li>RCC 开启时钟</li>
<li>选择时基单元的时钟源（此处选择内部时钟模式）</li>
<li>配置时基单元</li>
<li>配置输出中断，允许更新中断输出到 NVIC</li>
<li>配置 NVIC，在 NVIC 中打开定时器中断的通道，并分配一个优先级</li>
<li>运行控制，使能计数器</li>
</ol>
<h2 id="tim-输出比较pwm">TIM 输出比较（PWM）</h2>
<h3 id="简介">简介</h3>
<p><strong>OC</strong>（Output Compare）输出比较（其他缩写：<strong>IC</strong>（Input Capture）输入捕获、<strong>CC</strong>（Capture/Compare）输入捕获和输出比较单元）</p>
<p>输出比较可以通过比较 <code>CNT</code> 计数器与 <code>CCR</code> （捕获/比较寄存器） 寄存器值的关系，来对属于出电平进行置 1、置 0、翻转的操作，用于输出一定频率和占空比的 PWM 波形</p>
<p>每个通用和高级定时器都拥有 4 个输出比较通道。每个通道拥有独立的捕获/比较寄存器，但由于每个定时器只有一个 CNT 计数器，所以同一定时器不同通道的占空比可以不同，但频率是相同的</p>
<blockquote>
<p>高级定时器前 3 个通道额外拥有死区生成和互补输出的功能</p>
</blockquote>
<h3 id="pwm-简介">PWM 简介</h3>
<p>PWM（Pulse Width Modulation）脉冲宽度调制</p>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\PWM_0.png" alt=""></p>
<p>对于<strong>具有惯性的系统</strong>中，可以通过对一系列脉冲的宽度调制来等效的获得所需要的模拟参量，例如电机、LED 等</p>
<p>如上图所示，高低电平跳变的数字信号可以等效为蓝色虚线表示的模拟量。</p>
<p>上面电平时间 &gt; 下面电平时间：等效的模拟量偏向于上面</p>
<p>上面电平时间 &lt; 下面电平时间：等效的模拟量偏向于下面</p>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\PWM_1.png" alt=""></p>
<p>参数：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>频率</mtext><mo>=</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>T</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">频率 = 1 / Ts</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">频率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1/</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">s</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>占空比</mtext><mo>=</mo><mi>T</mi><mi>o</mi><mi>n</mi><mi mathvariant="normal">/</mi><mi>T</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">占空比 = Ton / Ts</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">占空比</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">s</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>分辨率</mtext><mo>=</mo><mtext>占空比变化步距</mtext></mrow><annotation encoding="application/x-tex">分辨率 = 占空比变化步距</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">分辨率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">占空比变化步距</span></span></span></span></p>
<p><strong>频率</strong>：频率越快，等效模拟的信号就越平稳，但性能开销就越大（一般 PWM 频率都在 x Khz ~ x0 KHz）</p>
<p><strong>占空比</strong>：占空比决定了 PWM 等效出来的模拟电压的大小（一般来说是线性关系的）</p>
<p><strong>分辨率</strong>：如果占空比只能是 1%、2%、3%以 1%进行步距跳变则分辨为 1%，如果可以是 1.1%、1.2%、1.3%以 0.1%的步距跳变则分辨率为 0.1%。分辨率也就是占空比变化的精细程度，需要多高具体看项目需求。越是高频率与高分辨率则对硬件电路的要求就越高</p>
<h3 id="通用输出比较通道">通用输出比较通道</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\PWM_2.png" alt=""></p>
<p><strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>N</mi><mi>T</mi><mo>&gt;</mo><mi>C</mi><mi>C</mi><mi>R</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">CNT &gt; CCR1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">CNT</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">CCR</span><span class="mord">1</span></span></span></span> / <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>N</mi><mi>T</mi><mo>=</mo><mi>C</mi><mi>C</mi><mi>R</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">CNT = CCR1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">CNT</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">CCR</span><span class="mord">1</span></span></span></span></strong>：让通道 1 的 CCR（捕获/比较寄存器）与 CNT 计数器进行比较，当满足以上两种条件中的任意一种时，给<strong>输出模式控制器</strong>传一个信号。</p>
<p><strong>输出模式控制器</strong>：当获得信号后，就会改变它输出<strong>oc1ref</strong>（ref：参考信号）的高低电平。该控制器输入 CNT 和 CCR 的大小关系，输出 REF 的高低电平，可通过 OC1M 寄存器[2:0]部分配置更多模式，模式见下图 👇</p>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\PWM_3.png" alt=""></p>
<ul>
<li>
<p><strong>冻结</strong>：当正在输出 PWM 时，向暂停一会输出，可以使用该模式使输出暂停（REF 高低电平保持为暂停前一刻的电平状态）</p>
</li>
<li>
<p><strong>匹配时置有效电平</strong>：有效电平是高等定时器的说法，类似于置高电平</p>
</li>
<li>
<p><strong>匹配时置无效电平</strong>：无效电平是高等定时器的说法，类似于置低电平</p>
</li>
<li>
<p><strong>匹配时电平翻转</strong>：字面意思。可以方便的输出一个频率可调，占空比始终为 50%的 PWM 波形</p>
</li>
<li>
<p><strong>强制为无效电平</strong>：与 CNT 和 CCR 值无关，强制将 REF 输出为低电平</p>
</li>
<li>
<p><strong>强制为有效电平</strong>：与 CNT 和 CCR 值无关，强制将 REF 输出为高电平</p>
</li>
</ul>
<p><strong>至主模式控制器（信号向上）</strong>：可以将<strong>oc1ref</strong>信号映射到主模式的<code>TRGO</code>输出上</p>
<p><strong>极性选择（信号向右）</strong>：选择是否要将输入的高低电平进行反转。给 CC1P 寄存器写 0，信号就会从上面（0 处）走<strong>信号电平不反转</strong>。写 1 则通过一个非门从下面（1 处）走，<strong>信号电平反转</strong></p>
<p><strong>输出使能电路</strong>：选择是否输出。通过置 CC1E 寄存器 1 或 0 实现</p>
<p><strong>OC1</strong>：也就是 CH1 通道的引脚，可在引脚定义表中查询具体哪个 GPIO 口</p>
<h3 id="pwm-基本结构">PWM 基本结构</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\PWM_4.png" alt=""></p>
<p>左上角为：<strong>时基单元</strong>和运行控制部分，时基单元左边为时钟源选择，详细在上一小节</p>
<p><code>CNT计数器值与CCR寄存器值进行比较 -&gt; 输出模式控制器选择PWM1模式 -&gt; 将REF输出到极性选择 -&gt; 最后输出给GPIO</code></p>
<p><strong>PWM1 模式逻辑参考右上图</strong></p>
<ul>
<li><strong>蓝色</strong>：CNT 计数器的值</li>
<li><strong>黄色</strong>：ARR 自动重装器值</li>
<li><strong>红色</strong>：CCR 捕获/比较器值</li>
<li><strong>绿色</strong>：REF 参考信号（输出控制器的输出）</li>
</ul>
<h3 id="参数计算">参数计算</h3>
<p><strong>PWM 频率</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>r</mi><mi>e</mi><mi>q</mi><mo>=</mo><mi>C</mi><msub><mi>K</mi><mi>P</mi></msub><mi>S</mi><mi>C</mi><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>P</mi><mi>S</mi><mi>C</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>A</mi><mi>R</mi><mi>R</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Freq = CK_PSC / (PSC + 1) / (ARR + 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">re</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.07153em;">SC</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">PSC</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.00773em;">RR</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<ul>
<li><strong>解释</strong>：从每个上升沿到下一个上升沿开始为一个周期，始终对应 CNT 计数器的一个溢出更新周期</li>
</ul>
<p><strong>PWM 占空比</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>u</mi><mi>t</mi><mi>y</mi><mo>=</mo><mi>C</mi><mi>C</mi><mi>R</mi><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>A</mi><mi>R</mi><mi>R</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Duty = CCR / (ARR + 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">CCR</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.00773em;">RR</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<ul>
<li><strong>解释</strong>：在每个周期中，值区间为 0 ~ ARR 值，在输出高电平的区间为 0 ~ CCR</li>
</ul>
<p><strong>PWM 分辨率</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>e</mi><mi>s</mi><mi>o</mi><mo>=</mo><mn>1</mn><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>A</mi><mi>R</mi><mi>R</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Reso = 1 / (ARR + 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">eso</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1/</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.00773em;">RR</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<ul>
<li><strong>解释</strong>：ARR 越大，CCR 的范围就越大，对应的分辨率就越大</li>
</ul>
<p><a href="./TOOLS/PWM%20Calc.c"><strong>随手写了个计算程序</strong></a></p>
<h3 id="实操-3">实操</h3>
<p>根据上述所得，使用 PWM 输出总共需要 5 个步骤：</p>
<ol>
<li>RCC 开启 TIM 外设和 GPIO 外设时钟</li>
<li>配置时基单元，包括前面的时钟源选择</li>
<li>配置输出比较单元，包括 CCR 值、输出比较模式、极性选择、输出使能</li>
<li>配置 GPIO，把 PWM 对应的 GPIO 口初始化为复用推挽输出的配置</li>
<li>运行控制，使能计数器</li>
</ol>
<h2 id="tim-输入捕获">TIM 输入捕获</h2>
<h3 id="简介-1">简介</h3>
<p>IC（Input Capture）输入捕获</p>
<p>输入捕获模式下，当通道输入引脚出现指定电平跳变（上升沿或下降沿等，可通过程序配置）时，当前 CNT 的值将被所存到 CCR 中（读取 CNT 计数器值到 CCR 锁存器中），可用于测量 PWM 波形的频率、占空比、脉冲间隔、电平持续时间等参数</p>
<p>通用和高级定时器每个都拥有 4 个输入捕获的通道</p>
<p>可配置为<strong>PWMI 模式</strong>，同时测量频率和占空比</p>
<p>可配合<strong>主从触发模式</strong>，实现硬件全自动测量</p>
<h3 id="频率测量">频率测量</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\IC_0.png" alt=""></p>
<ul>
<li>
<p><strong>测频法</strong>（左边）：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>x</mi><mo>=</mo><mi>N</mi><mi mathvariant="normal">/</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">fx = N / T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>适合测量高频信号。在闸门时间 T 内，对上升沿计次，得到 N，则频率 fx = N / T。根据频率定义可将 T 设为 1s，则计数 N 得到结果 x Hz。或是给 T * 系数 = 1s 即可</p>
</li>
<li>
<p><strong>测周法</strong>（右边）：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>x</mi><mo>=</mo><mi>f</mi><mi>c</mi><mi mathvariant="normal">/</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">fx = fc / N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">c</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>适合测量低频信号。两个上升沿内，以标准频率 fc 计次，得到 N，则频率 fx = fc / N。周期的倒数就是频率，如果测出一个周期的时间，取倒数就是频率。在一个周期内使用一个已知的频率 fc（使用定时器获得），计一个数的时间为 1 / fc，周期内总过计了 N 个数，则周期是 N / fc，取倒数则为频率</p>
</li>
<li>
<p><strong>中界频率</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>m</mi><mo>=</mo><mo stretchy="false">(</mo><mi>f</mi><mi>c</mi><mi mathvariant="normal">/</mi><mi>T</mi><msup><mo stretchy="false">)</mo><mo stretchy="false">(</mo></msup><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">fm = (fc / T) ^ (1 / 2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">c</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mopen mtight">(</span></span></span></span></span></span></span></span><span class="mord">1/2</span><span class="mclose">)</span></span></span></span>测频法与测周法误差相等的频率点</p>
</li>
</ul>
<h3 id="输入捕获模块结构">输入捕获模块结构</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\IC_1.png" alt=""></p>
<p><strong>TIMx_CH1~4</strong>：OC 引脚，具体参考引脚定义表</p>
<ul>
<li>
<p><strong>异或门</strong>：当 CH1~3 中的任何一个引脚发生电平翻转时，输出产生一次电平翻转</p>
<ul>
<li><strong>数据选择器</strong>：如果选择上路，则输出 3 个引脚的异或值。如果选择下路，则无效，每个通道输出各自引脚输入的信号（用处：配合前面的异或门为三相电机服务）</li>
</ul>
</li>
</ul>
<p><strong>输入滤波器和边沿检测器</strong>：滤波器对输入信号进行滤波，避免高频的毛刺信号导致误触发。边沿检测器与外部中断处类似，当出现指定的电平时就会触发后续电路。</p>
<blockquote>
<p>此处每通道都有两路滤波器和检测器，所以分别输出两路经过处理的信号（<code>TIxFP1</code>、<code>TIxFP2</code>（TIx Filter Polarity x））。以<code>CH1</code>和<code>CH2</code>为例：其中 CH1 的<code>TI1FP1</code>输出给 CH1（自己）的后续电路；<code>TI1FP2</code>则输出给 CH2 的后续电路；而 CH2 的<code>TI2FP1</code>输出给 CH1 的后续电路；<code>TI2FP2</code>则输出给 CH2（自己）的后续电路。<strong>用途：</strong></p>
</blockquote>
<ol>
<li>可以灵活切换后续捕获电路的输入，可以在 CH1 和 CH2 之间随意切换输入</li>
<li><strong>将一个引脚的输入同时映射到两个捕获单元中</strong>（PWMI 模式的结构：CH1 对上升沿进行捕获（捕获周期），CH2 对下降沿进行捕获（捕获占空比））</li>
</ol>
<ul>
<li><strong>TRC</strong>：TRC 信号来源于上面（其他定时器信号作为时钟源），服务于无刷电机驱动</li>
</ul>
<p><strong>预分频器</strong>：对前面输入的信号进行分频，然后输出信号触发捕获电路工作。捕获电路每触发一次，CNT 计数器的值就会向 CCR 寄存器转运一次，同时发生一个捕获事件（<code>CCxI</code>），该事件会在状态寄存器置标志位，同时也可产生中断（如果需要在捕获的瞬间处理一些事情，则可以开启捕获中断）</p>
<h3 id="单个输入捕获通道结构">单个输入捕获通道结构</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\IC_2.png" alt=""></p>
<p><strong>TI1</strong>：引脚输入信号</p>
<p><strong>fDTS</strong>：滤波器的采样时钟来源</p>
<p><strong>TIMx_CCMR1</strong>：寄存器的 ICF 位可以控制滤波器的参数，原理与其他滤波器相同</p>
<p><strong>TI1F</strong>：经过滤波后的引脚输入信号</p>
<p><strong>TIMx_CCER</strong>：使用<code>CC1P</code>位对边沿检测器控制数据选择器，选择<code>TI1FP1</code>输出触发上升沿还是下降沿信号，该信号通过数据选择器进入 CH1 后续捕获电路</p>
<p><strong>TIMx_CCMR1</strong>：<code>CC1S</code>位控制数据选择器对<code>TI1FP1</code>、<code>TI2FP1</code>、<code>TRC</code>数据进行选择（<code>IC1</code>）后进入分频器。<code>ICPS</code>位配置分频器，选择不分频、2 分频、4 分频、8 分频。</p>
<p><strong>TIMx_CCER</strong>：<code>CC1E</code>位控制输出使能或失能</p>
<p><strong>至从模式控制器</strong>：可以在捕获之后自动完成 CNT 的清零工作</p>
<h3 id="主从触发模式">主从触发模式</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\IC_3.png" alt=""></p>
<p>主从触发模式 = 主模式 + 从模式 + 触发源选择</p>
<p><strong>主模式</strong>：可以将定时器内部信号映射到 TRGO 引脚，用于触发其他外设</p>
<p><strong>从模式</strong>：可以接收其他外设或自身外设的一些信号（TRGI），用于控制自身定时器的运行，被别的信号控制。可在列表中选择一项操作来自动执行</p>
<p><strong>触发源选择</strong>：选择指定的一个信号，得到 TRGI。选择从模式的触发信号源，可认为是从模式的一部分</p>
<blockquote>
<p><strong>例 1</strong>：如想让 TI1FP1 信号自动触发 CNT 清零，在<strong>触发源选择</strong>处选择<code>TI1FP1</code>，<strong>从模式</strong>执行<code>Reset</code>操作</p>
</blockquote>
<blockquote>
<p><strong>例 2</strong>：想实现定时器的级联，可以选择一个定时器主模式输出<strong>更新模式</strong>信号到 TRGO，另一个定时器选择上一个定时器（<code>ITRx</code>）触发从模式，从模式选择执行<strong>外部时钟模式 1</strong>的操作，从而实现</p>
</blockquote>
<p><strong>主模式功能见下图 👇</strong></p>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\IC_4.png" alt=""></p>
<p><strong>触发选择功能见下图 👇</strong></p>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\IC_4_1.png" alt=""></p>
<p><strong>从模式功能见下图 👇</strong></p>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\IC_4_2.png" alt=""></p>
<h3 id="输入捕获基本结构">输入捕获基本结构</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\IC_5.png" alt=""></p>
<h3 id="pwmi-基本结构">PWMI 基本结构</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\IC_6.png" alt=""></p>
<h3 id="实操-4">实操</h3>
<p>根据上述所得，使用输入捕获测频率总共需要 7 个步骤：</p>
<ol>
<li>RCC 开启 GPIO 和 TIM 的时钟</li>
<li>GPIO 初始化，配置为输入模式（一般选择上拉输入/浮空输入模式）</li>
<li>配置时基单元，让 CNT 计数器在内部时钟驱动下自增运行</li>
<li>配置输入捕获单元，包括滤波器、极性、直连或交叉通道、分频器等参数</li>
<li>选择从模式的触发源<code>TI1FP1</code></li>
<li>选择触发之后的执行的操作，执行<code>Reset</code>操作</li>
<li>使能计时器。当我们需要读取最新的一个周期的频率时，直接读取 CCR1 的值，按照 fc（设 1Mhz） / 该值 即可</li>
</ol>
<h2 id="tim-编码器接口">TIM 编码器接口</h2>
<h3 id="简介-2">简介</h3>
<p>Encoder Interface 编码器接口</p>
<p>编码器接口可接收增量（正交）编码器的信号，根据编码器旋转产生的正交信号脉冲，自动控制 CNT 自增或自减，从而指示编码器的位置、旋转方向和旋转角度</p>
<p>每个通用定时器和高级定时器都拥有 1 个编码器接口。如果一个定时器被配置为编码器接口模式，则基本无法作为他用（两个输入引脚借用了输入捕获的 CH1 和 CH2）。F103C8T6 只有 4 个定时器，最多接 4 个编码器</p>
<h3 id="正交编码器">正交编码器</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\Encoder_0.png" alt=""></p>
<p>首先将 A 相和 B 相的所有边沿作为计数器的计数时钟，出现边沿信号时，就计数自增或自减。计数的方向根据另一相的状态来确定正反转</p>
<h3 id="编码器接口基本结构">编码器接口基本结构</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\Encoder_1.png" alt=""></p>
<p><strong>在该模式下，编码器接口的输出部分相当于从模式控制器</strong>，用来控制 CNT 的计数时钟和计数方向。此处不会使用 72MHz 的内部时钟与时基单元初始化</p>
<p>此处 ARR 也有效，一般设置为 65535（最大量程），利用补码的特性，很容易得到负数（<code>uint16</code> 转为 <code>int16</code>）</p>
<h3 id="工作模式">工作模式</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\Encoder_2.png" alt=""></p>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\Encoder_3.png" alt=""></p>
<h2 id="adc-模数转换器">ADC 模数转换器</h2>
<h3 id="简介-3">简介</h3>
<p>ADC（Analog - Digital Converter）模拟-数字转换器</p>
<p>ADC 可以将引脚上连续变化的<strong>模拟电压</strong>转化为内存中存储的<strong>数字变量</strong>，建立模拟电路到数字电路的桥梁</p>
<p>STM32<strong>系列</strong>的 ADC 是 12 位（分辨率：0 ~ (2 ^ 12) - 1 = 0 ~ 4095）逐次逼近型（工作模式）ADC，1us 转化时间（转化频率：从 AD 转化开始到产生结果需要花费 1us 事件，对应 AD 转化频率为 1MHz）</p>
<ul>
<li>
<p>输入电压范围：0 ~ 3.3v，转化结果范围：0 ~ 4095。0v 对应结果 0，3.3v 对应 4095，两者程线性关系</p>
</li>
<li>
<p>拥有 18 个输入通道，可测量 16 个外部（GPIO）和 2 个内部（内部温度传感器、内部参考电压（1.2v 左右的基准电压，不随外部供电电压变化而变化。<strong>该参考电压<code>VERFINT</code>与 ADC 参考电压<code>Vref+</code>应另当别论，<code>Vref+</code>取自 VCC 电压，随外部供电而改变</strong>））信号源</p>
</li>
<li>
<p>规则组（用于常规使用）和注入组（用于突发事件）两个转化单元，可以列一个组，一次性启动一个组，连续转化多个值</p>
</li>
<li>
<p>模拟看门狗自动检测输入电压范围。值高于或低于某个阈值这类的判断可以交给模拟看门狗自动执行，模拟看门狗可以检测指定的某些通道，当 AD 值高于它设定的上阈值或者低于下阈值时，它就会申请中断，可以在对应中断函数中执行相应操作。避免了不停的手动读值，再用 if 进行判断</p>
</li>
</ul>
<p>STM32F103C8T6 的 ADC 资源：ADC1、ADC2、10 个外部输入通道</p>
<h3 id="逐次逼近型-adc">逐次逼近型 ADC</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\ADC_0.png" alt=""></p>
<p>该图为 ADC0809 的内部结构图，是独立的 8 位逐次逼近型 ADC IC</p>
<p><strong>IN0~7</strong>：8 路输入通道，通过<strong>通道选择开关</strong>选中其中一路（通过下面的由<strong>ADDA~C</strong>输入的通道号到<strong>地址锁存和译码</strong>来进行。<strong>ALE</strong>为锁存与使能信号）</p>
<p><strong>比较器</strong>：电压比较器，将模拟电压值与编码数据对应。比较器输入端分别连接通过选择器选择后的输入待测电压，另一个是 DAC（输入数据，输出数据对应的电压。使用加权电阻网络实现）的电压输出端，通过比较输入端返回高点电平。如果 DAC 输出的电压较大就调小 DAC 数据，反之增大，直到 DAC 输出的电压与外部通道输入的电压近似相等，则 DAC 输入的数据就是外部电压的编码数据了。电压调节的过程就是通过逐次逼近 SAR 实现的</p>
<blockquote>
<p>为了更快找到对应编码，一般会使用二分法来查找。8 位的 ADC，编码就是从 0 ~ 255.第一次比较给 DAC 输入 255 的一半（128）进行比较。如果 DAC 电压大了，则再给 128 的一半（64），...以此类推。如果其中 DAC 输出电压 32 小了，就给 32 ~ 64 的中间值然后继续比较。如果使用二进制表示，128、64、32 等正好是二进制每一位的位权，相当于对二进制从高位到低位依次判断是 1 还是 0 的过程（逐次逼近型）</p>
</blockquote>
<p><strong>EOC</strong>：End of Convert，转换结束信号</p>
<p><strong>START</strong>：开始转化，输入一个脉冲开始</p>
<p><strong>CLOCK</strong>：ADC 时钟，因为 ADC 内部是一步一步进行判断的</p>
<p><strong>Vref</strong>：DAC 参考电压，将编码对应模拟电压，同时也决定了 ADC 的输入范围，ADC 的参考电压</p>
<h3 id="stm32-adc-框图">STM32 ADC 框图</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\ADC_1.png" alt=""></p>
<p><strong>输入</strong>：</p>
<p>位于左中部分</p>
<ul>
<li><strong>ADCx_IN0~15</strong>：ADC 的输入通道，包括 16 个 GPIO 口</li>
<li><strong>温度传感器</strong>：芯片内部温度传感器</li>
<li><strong>VREFINT</strong>：V Reference INternal，内部参考电压
这些通道（<code>F103C8T6</code>只有 10 个外部输入通道）全部输入<strong>模拟多路开关</strong></li>
</ul>
<p><strong>模拟多路开关</strong>：可以选择多路通道，且在转换的时候被分为<strong>规则通道组</strong>（可以一次性最多选中 16 个通道。但只有 1 个<strong>规则通道数据寄存器</strong>，会导致组里后来转化的值覆盖前一次转化的值，一般配合<code>#DMA</code>在转换完成后转运数据）和<strong>注入通道组</strong>（最多可以一次选中 4 个通道。<strong>注入通道数据寄存器</strong>有 4 个，每个转化后的结果都不会被组里其他数据覆盖）。右边是多路开关的输出，进入到模数转换器（执行前面提到的逐次比较的过程），转换结构会直接存放在<strong>通道数据寄存器</strong>中，通过读取寄存器得到 ADC 转换的结果。一般都使用规则组，数据覆盖问题配合使用 DMA 转运转化后的数据</p>
<p><strong>触发转化部分</strong>：</p>
<p>位于左下部分。相当于独立 ADC IC 的<code>START</code>信号，表示开始进行转化</p>
<ul>
<li>对于 STM32 的 ADC，触发开始转化的信号有两种：<strong>软件触发</strong>（在程序中手动调用函数启动转换）、<strong>硬件触发</strong>（选择触发源（<strong>开始触发（注入/规则组）</strong>，主要来自定时器，包含<code>TIMx_CHx</code>，<code>TRGO</code>定时器主模式输出））</li>
</ul>
<p><strong>供电</strong>：VDDA 与 VSSA 是 ADC 的供电引脚，且与 VREF 相连</p>
<p><strong>VREF</strong>：VREF+与 VREF-决定了 ADC 的参考电压，决定了 ADC 输入电压的范围。实际没有该引脚，在内部已经<strong>与供电引脚相连接</strong></p>
<p><strong>ADCCLK</strong>：ADC 的时钟，来自 ADC 的预分频器（源于 RCC（拥有 6、8 分频，结果分别为 14MHz、9MHz）），用于驱动内部逐次比较的时钟（也就是独立 ADC IC 的<code>CLOCK</code>输入）。</p>
<p><strong>转换完成信号</strong>：</p>
<p>位于上方<code>标志位</code>处</p>
<p>如果开启 NVIC 对应的通道，则转换完成后的状态寄存器会触发中断</p>
<ul>
<li><strong>EOC</strong>：规则组转换完成信号。完成后会在状态寄存器中置标志位</li>
<li><strong>JEOC</strong>：注入组完成的信号。完成后会在状态寄存器中置标志位</li>
</ul>
<h3 id="adc-基本结构图">ADC 基本结构图</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\ADC_2.png" alt=""></p>
<h3 id="输入通道">输入通道</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\ADC_3.png" alt=""></p>
<p><em>在引脚定义框图中<code>ADC12_INx</code>意思是 ADC1 和 ADC2 的 INx 通道</em></p>
<p>ADC1 和 ADC2 的输入引脚全都相同，此处用途为 ADC 的高级功能，双 ADC 模式（配合组成同步模式、交叉模式（ADC1 和 ADC2 交叉地对一个通道进行采样，进一步提高采样率）等）</p>
<h3 id="转换模式规则组为例">转换模式（规则组为例）</h3>
<p><strong>1. 单次转换，非扫描模式</strong>：</p>
<ul>
<li>
<p><strong>非扫描模式</strong>：规则组的序列中只有第一个有效，在里面写入要转换的通道</p>
</li>
<li>
<p><strong>单次转化</strong>：触发转换后，ADC 就会对序列 1 的通道进行模数转换。当转换完成，转换结果将会放在数据寄存器中，同时给 EOC 标志位置 1</p>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\ADC_4.png" alt=""></p>
</li>
</ul>
<p><strong>2. 连续转换，非扫描模式</strong>：</p>
<ul>
<li>
<p><strong>非扫描模式</strong>：规则组的序列中只有第一个有效，在里面写入要转换的通道</p>
</li>
<li>
<p><strong>连续转换</strong>：当一次转换结束后不会停止，而是立即进行下一轮的转换，然后一直持续下去。这样子只需要最开始触发一次，之后就可以一直转换了，不用再判断是否结束后再次开启转换</p>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\ADC_5.png" alt=""></p>
</li>
</ul>
<p><strong>3. 单次转换，扫描模式</strong>：</p>
<ul>
<li>
<p><strong>扫描模式</strong>：可以在序列中写入多个需要转换的通道（<strong>通道位置任意、允许重复</strong>，初始化结构体中需要定义序列中待转换通道的数目，ADC 将按顺序将转换的结果都存入同一个寄存器中（规则组）</p>
</li>
<li>
<p><strong>单次转化</strong>：触发转换后，ADC 就会对序列 1 的通道进行模数转换。当转换完成，转换结果将会放在数据寄存器中，同时给 EOC 标志位置 1</p>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\ADC_6.png" alt=""></p>
</li>
</ul>
<p><strong>4. 连续转换，扫描模式</strong>：</p>
<ul>
<li>
<p><strong>扫描模式</strong>：可以在序列中写入多个需要转换的通道（<strong>通道位置任意、允许重复</strong>，初始化结构体中需要定义序列中待转换通道的数目，ADC 将按顺序将转换的结果都存入同一个寄存器中（规则组）</p>
</li>
<li>
<p><strong>连续转换</strong>：当一次转换结束后不会停止，而是立即进行下一轮的转换，然后一直持续下去。这样子只需要最开始触发一次，之后就可以一直转换了，不用再判断是否结束后再次开启转换</p>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\ADC_7.png" alt=""></p>
</li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>在<strong>扫描模式</strong>的情况下，还可以有一种模式，<strong>间断模式</strong>。在扫描的过程中，每隔几个转换（也就是转换序列中的通道模拟电压），就暂停一次。<strong>了解即可</strong></li>
</ul>
<h3 id="触发控制">触发控制</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\ADC_8.png" alt=""></p>
<p>也就是每个组<strong>触发控制</strong>可以进行选择的部分</p>
<p><strong>EXTI 线 11/TIM8_TRGO 事件</strong>：这个信号类型可以是引脚，也可以是定时器，具体需要用 AFIO 重映射来确定</p>
<h3 id="数据对齐">数据对齐</h3>
<p><strong>一般使用数据<code>右对齐</code>，这样直接读取数据就是转换结果</strong></p>
<p><code>左对齐</code>一般用来降低采集精度（真有这种需求吗？）</p>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\ADC_9.png" alt=""></p>
<h3 id="转换时间">转换时间</h3>
<ul>
<li>
<p>AD 转换的步骤：采样，保持，量化，编码</p>
</li>
<li>
<p>STM32 ADC 的总转换时间为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>c</mi><mi>o</mi><mi>n</mi><mi>v</mi><mo>=</mo><mtext>采样时间</mtext><mo>+</mo><mn>12.5</mn><mtext>个</mtext><mi>A</mi><mi>D</mi><mi>C</mi><mtext>周期</mtext></mrow><annotation encoding="application/x-tex">Tconv = 采样时间 + 12.5个ADC周期</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">co</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">采样时间</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">12.5</span><span class="mord cjk_fallback">个</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord cjk_fallback">周期</span></span></span></span></p>
<ul>
<li>
<p><strong>采样时间</strong>：采样保持所花费的时间，程序中可配置。采样的时间越大，越能避免一些毛刺信号的干扰，但转化时间也会相应延长</p>
</li>
<li>
<p><strong>12.5 个 ADC 周期</strong>：量化编码所花费的时间。因为是 12 位 ADC 所以需要花费 12 个周期，剩下 0.5 个周期可能是做其他事情而花费。ADC 周期是从 RCC 分频过来的<code>ADCCLK</code>（最大 14MHz）</p>
<p>例：当 ADCCLK = 14MHz，采样时间位 1.5 个 ADC 周期：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>c</mi><mi>o</mi><mi>n</mi><mi>v</mi><mo>=</mo><mn>1.5</mn><mo>+</mo><mn>12.5</mn><mo>=</mo><mn>14</mn><mtext>个</mtext><mi>A</mi><mi>D</mi><mi>C</mi><mtext>周期</mtext><mo>=</mo><mn>1</mn><mi>u</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">Tconv = 1.5 + 12.5 = 14个ADC周期 = 1us</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">co</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1.5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">12.5</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">14</span><span class="mord cjk_fallback">个</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord cjk_fallback">周期</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span></span></span></span></p>
</li>
</ul>
</li>
</ul>
<h3 id="校准">校准</h3>
<ul>
<li>
<p>ADC 有一个内置自校准模式。校准可以大幅减小因内部电容器组的变化而造成的精度误差。校准期间，在每个电容器上都会计算出一个误差修正码（数字值），这个码用于消除在随后的转换中每个电容器上产生的误差</p>
</li>
<li>
<p>建议在每次上电后执行一次校准</p>
</li>
<li>
<p>启动校准前，ADC 必须处于关电状态超过至少两个 ADC 时钟周期</p>
</li>
<li>
<p><strong>注意：该过程为自动的，仅需在 ADC 初始化最后添加几行代码即可</strong></p>
</li>
</ul>
<h3 id="硬件电路">硬件电路</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\ADC_10.png" alt=""></p>
<h3 id="实操-5">实操</h3>
<p>根据上述所得，使用软件触发 ADC 单次非扫描模式测量输入模拟电压总共需要 5 个步骤：</p>
<ol>
<li>RCC 开启 ADC 和 GPIO 的时钟，注意 ADCCLK 的分频器也得配置</li>
<li>GPIO 配置模拟输入模式</li>
<li>配置多路开关，将左边通道接入右边规则组列表中</li>
<li>配置 ADC，使用结构体配置 AD 转换器和 AD 数据寄存器的参数。如果需要配置模拟看门狗则调用对应函数即可配置阈值和监测通道</li>
<li>开关控制，使用<code>ADC_Cmd</code>函数开启 ADC。根据手册建议可以对 ADC 进行校准，减小误差</li>
</ol>
<p>在 ADC 工作时，如果想用软件触发转换、读取转换结果，都可以调用对应函数</p>
<h2 id="dma-直接存储器存取">DMA 直接存储器存取</h2>
<h3 id="dma-简介">DMA 简介</h3>
<p>提供<strong>外设和存储器</strong>或者<strong>存储器和存储器</strong>之间的高速数据传输 ，<strong>无需 CPU 干预，节省了 CPU 的资源</strong></p>
<blockquote>
<p>外设：指外设的数据寄存器（<strong>D</strong>ata <strong>R</strong>egister），例如 ADC 的 DR、串口的 DR 等</p>
</blockquote>
<blockquote>
<p>存储器：指运行内存 SRAM 和程序存储器 Flash</p>
</blockquote>
<p>STM32F103C8T6 仅含有 DMA1（7 个通道），每个通道都支持<strong>软件触发</strong>和特定的<strong>硬件触发</strong></p>
<blockquote>
<p>数据从一个地方转移到另一个地方就需要占用一个通道。多个通道之间可以各转各的，互不干扰</p>
</blockquote>
<blockquote>
<p>如果是存储器到存储器之间的转运则需要软件触发（如需要把 Flash 里一批数据转运到 SRAM 中）。如果是外设到存储器的转运则因外设数据有一定时机所以需要使用硬件触发（如转运 ADC 的数据，要等 ADC 每个 AD 转换完成后，硬件触发 DMA 再进行 DMA 转运）</p>
<blockquote>
<p><strong>特定的</strong>指：每个 DMA 通道的硬件触发源不同，<strong>外设要使用对应通道 DMA 就需要使用该通道连接的那个通道，不能任意选择通道（在#DMA 请求中有再次说明）</strong></p>
</blockquote>
</blockquote>
<h3 id="存储器映像">存储器映像</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\DMA_0.png" alt=""></p>
<blockquote>
<p>外设和存储器的转运本质上都是存储器和存储器之间的转运，只不过 STM32 特别指定了可以转运外设存储器而已</p>
</blockquote>
<p>表中存储器分为两类：<strong>ROM</strong>和<strong>RAM</strong></p>
<p>ROM：只读存储器，非易失性、掉电不丢失的存储器</p>
<p>RAM：随机存储器，易失性、掉电丢失的存储器</p>
<p><strong>*可用地址来确定数据存储器类型</strong></p>
<blockquote>
<p>选项字节再 ROM 区的最后面，下载程序时可以选择不刷新选项字节的内容，这样选项字节的配置可以保持不变。选项字节主要是 Flash 的读、写保护，看门狗等的配置</p>
</blockquote>
<p><a href="./PDF/STM32F103x8B%E6%95%B0%E6%8D%AE%E6%89%8B%E5%86%8C%EF%BC%88%E4%B8%AD%E6%96%87%EF%BC%89.pdf">参考文档：STM32F103x8B 数据手册（中文）/ #存储器映像</a></p>
<h3 id="dma-框图">DMA 框图</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\DMA_1.png" alt=""></p>
<p>核心中包含 CPU 和内核外设等，其余均可看作存储器</p>
<p>总线矩阵：总线矩阵的左端为主动单元（拥有存储器的访问权），右端为被动单元（存储器只能被左端主动单元读写）</p>
<blockquote>
<p>DCode 总线专门访问 Flash，系统总线访问其他存储器，由于 DMA 要转运数据所以也必须要有访问主动权</p>
</blockquote>
<p><em>由此可得主动单元包括：CPU 内核、DMA 总线</em></p>
<p><strong>仲裁器</strong>作用：用于调度各个通道，防止产生冲突。由于 DMA 总线只有一条所以当通道传递数据冲突时根据通道优先级进行传输</p>
<p>在总线矩阵中也含有仲裁器，若 CPU 和 DMA 都要访问同一个目标则会使 DMA 优先，暂停 CPU 访问以防止冲突，不过总线仲裁器仍然会保证 CPU 得到一半的总线带宽</p>
<p><strong>AHB 从设备</strong>：用于配置 DMA 参数，也就是 DMA 自身的配置寄存器。因连接到了右边的 AHB 总线，所以 DMA 既是总线矩阵的主动单元，可读写各种存储器也是 AHB 上的被动单元。通过<code>CPU内核-&gt;系统-&gt;总线矩阵-&gt;AHB总线-&gt;AHB从设备</code>就可以对 DMA 进行配置了</p>
<p><strong>DMA 请求</strong>：用于硬件触发 DMA 的数据转运。连接着各个外设所以是 DMA 的硬件触发源</p>
<h3 id="dma-基本结构">DMA 基本结构</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\DMA_2.png" alt=""></p>
<p><strong>方向</strong>：控制数据传输方向（外设到存储器/存储器到存储器）</p>
<p><strong>外设&amp;存储器参数</strong>：</p>
<ul>
<li>
<p><strong>起始地址</strong>：该地址决定数据是从哪里来到哪里去的</p>
</li>
<li>
<p><strong>数据宽度</strong>：指定一次转运要按多大的数据宽度来进行（字节 Byte（uint8_t）、半字 HalfWord（uint16_t）、字 Word（uint32_t））。如转运 ADC 的数据，其数据宽度为 16 位，所以参数选择半字</p>
</li>
<li>
<p><strong>地址是否自增</strong>：指定一次转运完成后，下一次转运是否要把地址移动到下一个位置去，类似指针 p++的效果。</p>
</li>
</ul>
<p>例：（ADC 扫描模式，用 DMA 进行数据转运）：外设地址为 ADC_DR 寄存器。外设 DR 地址不用递增，否则将会转移其他寄存器的数据；而存储器的地址需要递增，每转运一个数据后就向后移动，否则就会覆盖上次转运的数据结果</p>
<blockquote>
<p>图中外设与存储器仅作为名称，也可称为站点 A、B</p>
</blockquote>
<p><strong>传输计数器</strong>：用来指定总共需要转运几次。是自减计数器，当减到 0 时停止数据转运，且自增的地址也会恢复到起始地址的位置</p>
<p><strong>自动重装器</strong>：决定了转运的模式（单次模式（如转运数组）、循环模式（如 ADC 扫描模式+连续转换））。当传输计数器到 0 时决定是否要恢复到最初的值。若不使用则 DMA 结束，否则立即重装到初始值</p>
<p><strong>DMA 触发控制</strong>：决定 DMA 要在什么时机进行转运。可选择硬件触发或软件触发，由<code>M2M</code>（Memory to Memory）参数（0 / 1）决定</p>
<ul>
<li>
<p><strong>软件触发</strong>（M2M = 1）：并非是调用某个函数一次触发一次，而是以最快的速度连续不断的触发 DMA，直到传输计数器为 0 结束该轮循环，可理解为<strong>连续触发</strong>。<strong>软件触发与循环模式（自动重装器）不能同时使用，否则 DMA 将会进入死循环</strong>。软件触发一般适用于存储器到存储器的转运，因为是软件启动，不需要时机，且想尽快完成</p>
</li>
<li>
<p><strong>硬件触发</strong>（M2M = 0）：硬件触发源可选择 ADC、串口、定时器等。因为其需要一定的时机，如 ADC 转化完成、串口收到数据、定时器到设定时间等，在硬件到达时机时发送信号触发 DMA 进行转运</p>
</li>
</ul>
<p><strong>开关控制</strong>：也就是<code>DMA_Cmd</code>函数，用于给 DMA 使能</p>
<p>以上可得，DMA 的转运条件有：</p>
<ol>
<li>
<p>开关控制：<code>DMA_Cmd</code>必须使能</p>
</li>
<li>
<p>传输计数器：值必须大于 0</p>
</li>
<li>
<p>触发源（M2M = 0 / 1）：必须要有触发信号</p>
</li>
</ol>
<p>触发一次进行一次转运，传输计数器自减一次。若没有自动重装时，无论是否触发，DMA 都不会再进行转运。<strong>若想再次开启则需要先给<code>DMA_Cmd</code>传入<code>DISABLE</code>关闭 DMA，再给传输计数器一个大于 0 的数后再给<code>DMA_Cmd</code>传入<code>ENABLE</code>开启 DMA，即可继续工作</strong></p>
<blockquote>
<p>在给传输计数器赋值时必须要先关闭 DMA 再进行（手册规定）</p>
</blockquote>
<h3 id="dma-请求">DMA 请求</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\DMA_3_1.png" alt=""></p>
<p><strong>该图 👇 为上小节 DMA 触发源选择 👆 的详细结构</strong></p>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\DMA_3.png" alt=""></p>
<p>该图为<strong>DMA1</strong>的请求映像，共有 7 个通道</p>
<p>每个通道都有一个数据选择器可以选择<strong>硬件触发</strong>或<strong>软件触发</strong></p>
<p><strong>在此图中</strong>：</p>
<ul>
<li>
<p><strong>侧边 EN 位</strong>：决定该数据选择器是否工作，EN = 0 时不工作，EN = 1 时工作</p>
</li>
<li>
<p><strong>软件触发（MEM2MEM 位）</strong>：当该值 = 1 时使用软件触发，= 0 时使用硬件触发。如果使用软件触发则无通道的限制，可以任意选择</p>
</li>
<li>
<p><strong>外设请求信号</strong>：按照硬件源选择对应通道。如需要用 ADC1<code>ADC1</code>来触发就必须选择通道 1，如果需要定时器 2 的更新事件<code>TIM2_UP</code>来触发就必须选择通道 2</p>
</li>
</ul>
<p><strong>同一通道多个触发源选择哪一个？</strong>：根据对应的外设是否开启 DMA 输出决定。如使用<code>ADC1</code>，则会有库函数<code>ADC_DMACmd</code>，使用该函数开启<code>ADC1</code>这一路的输出才有效；如选择<code>TIM2_CH3</code>则使用<code>TIM_DMACmd</code>来进行 DMA 输出控制。外设请求信号经过一个<strong>或门</strong>进入数据选择器，所以按理说全部开启都可以进行触发</p>
<p><strong>仲裁器</strong>：类似于中断的优先级。通道号越小，优先级越高。也可在程序中配置优先级</p>
<h3 id="数据宽度与对齐">数据宽度与对齐</h3>
<p><strong>*简单来讲</strong>：</p>
<ul>
<li>
<p><strong>小转大</strong>：高位补 0</p>
</li>
<li>
<p><strong>大转小</strong>：舍弃高位</p>
</li>
</ul>
<p>手册如下：</p>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\DMA_4.png" alt=""></p>
<h3 id="实操-6">实操</h3>
<p><strong><code>const</code>类型常量会被编译器划分到<code>Flash</code>中，如果是比较大的查找表或字库尽量加<code>const</code>节省<code>SRAM</code>空间</strong></p>
<p><strong>如果使用<code>硬件触发</code>，则需要在对应的硬件调用<code>xxx_DMACmd</code>开启触发信号的输出</strong></p>
<p><strong>如果需要 DMA 中断，则需要调用<code>DMA_ITConfig</code>开启中断输出，再在 NVIC 配置相应的中断通道，然后写中断函数即可</strong></p>
<ol>
<li>
<p>初始化 DMA，并将 DataA 数据转运到 DataB 中：</p>
<ol>
<li>RCC 开启 DMA 时钟</li>
<li>直接调用<code>DMA_Init</code>配置参数</li>
<li>使能，开启 DMA</li>
</ol>
</li>
<li>
<p>使用 DMA 与 ADC 扫描模式相互配合实现模拟量自动采集与转运：</p>
<ol>
<li>RCC 开启 ADC、DMA、GPIO 时钟</li>
<li>配置 GPIO 为模拟输入</li>
<li>配置 ADC，并调用 ADC_DMACmd 开启 ADC 到 DMA 的通道，且配置为连续扫描模式</li>
<li>配置 DMA，配置为硬件触发，连续模式</li>
<li>使能 DMA、ADC</li>
<li>校准 ADC</li>
<li>软件开启 ADC，全套电路开始自动工作</li>
</ol>
</li>
</ol>
<h2 id="usart-串口">USART 串口</h2>
<h3 id="通信接口">通信接口</h3>
<ul>
<li>
<p>通信的目的：将一个设备的数据传送到另一个设备，扩展硬件系统</p>
</li>
<li>
<p>通信协议：制定通信的规则，通信双方按照协议规则进行数据收发</p>
</li>
</ul>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\USART_0.png" alt=""></p>
<p><strong>名称</strong>：</p>
<ul>
<li>
<p><strong>USART</strong>：</p>
<ul>
<li><strong>TX</strong>：也可写作 TXD（Transmit Exchange）数据发送脚</li>
<li><strong>RX</strong>：也可写作 RXD（Receive Exchange）数据接收脚</li>
</ul>
</li>
<li>
<p><strong>I2C</strong>：</p>
<ul>
<li><strong>SCL</strong>：（Serial Clock）时钟</li>
<li><strong>SDA</strong>：（Serial Data）数据</li>
</ul>
</li>
<li>
<p><strong>SPI</strong>：</p>
<ul>
<li><strong>SCLK</strong>：（Serial Clock）时钟</li>
<li><strong>MOSI</strong>：（Master Output Slave Input）主机输出数据脚</li>
<li><strong>MISO</strong>：（Master Input Slave Output）主机输入数据脚</li>
<li><strong>CS</strong>：（Chip Select）片选，用于指定通信的对象</li>
</ul>
</li>
<li>
<p><strong>CAN</strong>：</p>
<ul>
<li><strong>CAN_H、CAN_L</strong>：差分数据引脚，用两个引脚表示一个差分数据</li>
</ul>
</li>
<li>
<p><strong>USB</strong>：</p>
<ul>
<li><strong>DP</strong>：或 D+（Data Positive），也是差分数据脚</li>
<li><strong>DM</strong>：或 D-（Data Minus）</li>
</ul>
</li>
</ul>
<p><strong>双工</strong>：</p>
<ul>
<li><strong>全双工</strong>：通信双方能够同时进行双向通信，一般全双工的通信都有两根通信线</li>
</ul>
<p><em>单工：数据只能从一个设备到另一个设备，不能反向转移</em></p>
<p><strong>时钟</strong>：</p>
<ul>
<li><strong>异步</strong>：需要双方约定一个采样频率，且需要增加一些帧头帧尾等进行采样位置的对齐</li>
<li><strong>同步</strong>：接收方可以在时钟信号的指引下进行采样</li>
</ul>
<p><strong>电平</strong>：</p>
<ul>
<li><strong>单端</strong>：引脚数据的高低电平都是对 GND 的电压差，所以单端信号通信双方必须要共地</li>
<li><strong>差分</strong>：靠两个引脚的电压差来传输信号，通信时可以不需要共地（USB 需要共地）。使用差分信号可以极大的提高抗干扰特性</li>
</ul>
<p><strong>设备</strong>：</p>
<ul>
<li><strong>点对点</strong>：只需要发送和接收数据即可</li>
<li><strong>多设备</strong>：需要有寻址的过程，确定通信的对象</li>
</ul>
<h3 id="串口通信">串口通信</h3>
<ul>
<li>
<p>串口是一种应用十分广泛的通信接口，串口成本低、容易使用、通信线路简单，可实现两个设备的互相通信</p>
</li>
<li>
<p>单片机的串口可以使单片机与单片机、单片机与电脑（如串口通信：可以用来调试程序，打印信息）、单片机与各式各样的模块相互通信，极大的扩展了单片机的应用范围，增强了单片机的系统的硬件实力</p>
</li>
</ul>
<h3 id="硬件电路-1">硬件电路</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\USART_1.png" alt=""></p>
<ul>
<li>
<p><code>TX</code>与<code>RX</code>要交叉连接。A 发送到 B 接收，A 接收到 B 发送</p>
</li>
<li>
<p>当电平标准不一致时，需要加电平转换芯片。一般直接从控制器里出来的信号都是 TTL 电平（晶体管-晶体管逻辑电平），相同的电平才能相互通信</p>
</li>
</ul>
<h3 id="电平标准">电平标准</h3>
<p>电平标准是数据 1 和数据 0 的表达方式，是传输线缆中人为规定的电压与数据的对应关系，串口常用的电平标准有如下三种：</p>
<ul>
<li><strong>TTL 电平</strong>：+3.3v 或+5v（依 VCC 电压而定）表示 1，0v 表示 0</li>
<li><strong>RS232 电平</strong>：-3 ~ -15v 表示 1，+3 ~ +15v 表示 0</li>
<li><strong>RS485 电平</strong>：两线压差+2 ~ +6v 表示 1，-2 ~ -6v 表示 0（差分信号）</li>
</ul>
<h3 id="串口参数及时序">串口参数及时序</h3>
<ul>
<li><strong>波特率</strong>：串口通信的速率</li>
<li><strong>起始位</strong>：标志一个数据帧的开始，固定为低电平.当引脚空闲时为高电平</li>
<li><strong>数据位</strong>：数据帧的有效载荷，1 为高电平，0 为低电平，<strong>低位先行（数据从低位开始发送）</strong></li>
<li><strong>校验位</strong>：用于数据验证，根据数据位计算得来。计数 1 的数量，使用无校验、奇校验、偶校验，判断数据传输是否出错</li>
<li><strong>停止位</strong>：用于数据帧间隔，固定为高电平</li>
</ul>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\USART_2.png" alt=""></p>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\USART_2_1.png" alt=""></p>
<h3 id="usart-简介">USART 简介</h3>
<p>USART（Universal Synchronous/Asynchronous Receiver/Transmitter）通用同步（STM32 的该模式只是多了个时钟输出功能，但不支持时钟输入。仅为兼容别的协议或者特殊用途而设计）/异步收发器</p>
<p>USART 是 STM32 内部集成的硬件外设，可根据数据寄存器的一个字节数据自动生成数据帧时序，从 TX 引脚发送出去，也可自动接收 RX 引脚的数据帧时序，拼接为一个字节数据，存放在数据寄存器里</p>
<ul>
<li>
<p>自带波特率发生器（常用<strong>9600</strong> / 115200），最高达 4.5Mbits/s</p>
</li>
<li>
<p>可配置数据位长度（<strong>8</strong>（常用） / 9）、停止位长度（0.5 / <strong>1</strong>（常用） / 1.5 / 2）</p>
</li>
<li>
<p>可选校验位（<strong>无校验</strong>（常用） / 奇校验 / 偶校验）</p>
</li>
<li>
<p>支持同步模式（多了个时钟 CLK 输出）、硬件流控制（告诉发送端是否准备好接收数据，防止因发送过快而导致数据被覆盖）、DMA（UASRT 支持 DMA 进行数据转运）、智能卡（用于 NFC）、IrDA（用于红外通信，不是红外遥控器的通信）、LIN（局域网通信协议）</p>
</li>
<li>
<p>STM32F103C8T6 的 USART 资源：<strong>USART1（APB2）</strong>、USART2（APB1）、USART3（APB1）</p>
</li>
</ul>
<h3 id="usart-框图">USART 框图</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\USART_3.png" alt=""></p>
<p><em>因为将寄存器的位全都画出来了所以看着复杂（</em></p>
<p>左上角：</p>
<ul>
<li>
<p>TX、RX：发送和接收引脚。RX 从<strong>发送移位寄存器</strong>输出，TX 输入到<strong>接收移位寄存器</strong></p>
</li>
<li>
<p>SW_RX、IRDA_OUT/IN：智能卡和 IrDA 通信的引脚</p>
</li>
</ul>
<p>右上角：</p>
<p>串口的数据寄存器，发送或接收的字节数据就存储在此</p>
<ul>
<li>
<p><strong>发送数据寄存器（TDR）、接收数据寄存器（RDR）</strong>：（Transmit DR、Receive DR）。硬件中含有两个寄存器但是在软件中二者共占同一个地址，程序上都用 DR 来表示。TDR 只写、RDR 只读，当执行 DR<strong>写</strong>操作时，数据写入<strong>TDR</strong>；当执行 DR<strong>读</strong>操作时，数据写入<strong>RDR</strong></p>
</li>
<li>
<p><strong>发送移位寄存器</strong>：把一个字节的数据一位一位的移出去，对应串口协议的数据位。当发送数据寄存器（TDR）写入一个数据，硬件就会检测到数据被写入，并检查当前移位寄存器是否有数据正在移位。如果没有，就立即将 TDR 数据移入<strong>发送移位寄存器</strong>中。当数据从 TDR 移动到发送移位寄存器时，会置一个标志位 TXE（TX Empty）发送寄存器空，如果该标志位置 1，就可以在 TDR 写入下一个数据了（当 TXE 置 1 时，仅是数据从 TDR 中被转移，但还未发送出去）。<strong>发送控制器</strong>就会驱动发送移位寄存器向右将数据一位一位输出至 TX 引脚</p>
</li>
<li>
<p><strong>接收移位寄存器</strong>：与发送移位寄存器类似，数据从 RX 引脚通向接收移位寄存器，在<strong>接收控制器</strong>的驱动下，一位一位的读取 RX 电平到高位，再进行右移。当接收一个字节完成后，会将数据立即转移到 RDR 中，并置 RXNE 标志位（RX Not Empty）接收数据寄存器非空。当检测到 RXNE 置 1 后，就可以读取数据了</p>
</li>
<li>
<p><strong>发送控制器</strong>：用来控制发送移位寄存器的工作</p>
</li>
<li>
<p><strong>接收控制器</strong>：用来控制接收移位寄存器的工作</p>
</li>
</ul>
<p>左边：</p>
<ul>
<li><strong>硬件数据流控</strong>：也就是硬件流控制（流控）
<ul>
<li><strong>nRTS</strong>：（Request To Send）请求发送，输出脚。告诉对方当前能不能接收数据</li>
<li><strong>nCTS</strong>：（Clear To Send）清除发送，输入脚。用于接收别人的 nRTS 信号</li>
<li><strong>注意</strong>：<code>n</code>的意思是低电平有效</li>
</ul>
</li>
</ul>
<p>右边：</p>
<ul>
<li><strong>SCLK</strong>：用于产生同步的时钟信号。配合移位寄存器输出的，发送寄存器每移位一次，同步时钟电平就跳变一个周期</li>
</ul>
<p>中间：</p>
<ul>
<li>
<p><strong>唤醒单元</strong>：进行一个寻址的过程，用于实现与多设备通信的功能</p>
</li>
<li>
<p><strong>USART 中断控制</strong>：中断申请位就是 SR 状态寄存器中的各种标志位，其中<code>TXE（发送寄存器空）</code>、<code>RXNE（接收寄存器非空）</code>比较重要</p>
</li>
</ul>
<p>下面：</p>
<ul>
<li>
<p><strong>波特率发生器</strong>：也就是将 72MHz 分频的分频器。时钟输入是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>P</mi><mi>C</mi><mi>L</mi><mi>K</mi><mi>x</mi><mtext>（</mtext><mi>x</mi><mo>=</mo><mn>1</mn><mtext>（</mtext><mi>U</mi><mi>S</mi><mi>A</mi><mi>R</mi><mi>T</mi><mn>2</mn><mtext> </mtext><mn>3</mn><mtext>在</mtext><mi>A</mi><mi>P</mi><mi>B</mi><mn>1</mn><mtext>上，</mtext><mn>36</mn><mi>M</mi><mi>H</mi><mi>z</mi><mtext>）</mtext><mi mathvariant="normal">/</mi><mn>2</mn><mtext>（</mtext><mi>U</mi><mi>S</mi><mi>A</mi><mi>R</mi><mi>T</mi><mn>1</mn><mtext>在</mtext><mi>A</mi><mi>P</mi><mi>B</mi><mn>2</mn><mtext>上，</mtext><mn>72</mn><mi>M</mi><mi>H</mi><mi>z</mi><mtext>））</mtext></mrow><annotation encoding="application/x-tex">fPCLKx（x = 1（USART2~3在APB1上，36MHz） / 2（USART1在APB2上，72MHz））</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.07153em;">PC</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal">x</span><span class="mord cjk_fallback">（</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord cjk_fallback">（</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.13889em;">RT</span><span class="mord">2</span><span class="mspace nobreak"> </span><span class="mord">3</span><span class="mord cjk_fallback">在</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">PB</span><span class="mord">1</span><span class="mord cjk_fallback">上，</span><span class="mord">36</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal" style="margin-right:0.04398em;">Hz</span><span class="mord cjk_fallback">）</span><span class="mord">/2</span><span class="mord cjk_fallback">（</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.13889em;">RT</span><span class="mord">1</span><span class="mord cjk_fallback">在</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">PB</span><span class="mord">2</span><span class="mord cjk_fallback">上，</span><span class="mord">72</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal" style="margin-right:0.04398em;">Hz</span><span class="mord cjk_fallback">））</span></span></span></span>，之后该时钟进行分频，除以<code>USARTDIV</code>的分频系数（参考 USART_BRR，分为整数部分（<code>DIV_Mantissa</code>）和小数部分（<code>DIV_Fraction</code>）），最后除以 16，从而得到发送器时钟和接收器时钟，通向控制部分。</p>
</li>
<li>
<p><strong>USART_BRR</strong>：如果 TE（TX Enable）为 1，则发送器使能，发送部分的波特率有效。如果 RE（RX Enable）为 1，则接收器使能，接收部分的波特率有效。</p>
</li>
</ul>
<h3 id="usart-基本结构">USART 基本结构</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\USART_4.png" alt=""></p>
<h3 id="数据帧">数据帧</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\USART_5.png" alt=""></p>
<p>这里提供了 4 种模式：8 / 9 位字长，带 / 不带校验位</p>
<p>一般设置为：8 位不带校验位、9 位带校验位</p>
<p>下面的空闲帧和断开帧是局域网协议使用的</p>
<p>停止位分为 0.5、1、1.5、2，对应为一个数据位乘该系数的长度</p>
<h3 id="起始位侦测">起始位侦测</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\USART_6.png" alt=""></p>
<p>当输入电路侦测到第一个数据帧的起始位后，就会以波特率的频率，连续采样一帧数据</p>
<p>同时，从起始位开始，采样位置就要对齐到位的正中间（只要第一位对齐，后面肯定都是齐的）</p>
<p>采集时钟会以波特率的 16 倍进行采样（在一位的时间长度中可以进行 16 次采样）</p>
<p>检测到下降沿后就会开始以下检测步骤：</p>
<ul>
<li>
<p>判断条件要求每 3 位中至少应该有 2 个 0，如果没有噪声则全是 0，满足情况。如果有轻微的噪声，导致 3 位中只有 2 个 0，另一个是 1，也算检测到起始位，但是会在状态寄存器中置 NE（Noise Error）噪声标志位</p>
</li>
<li>
<p>如果 3 位里只有 1 个 0 或没有，那么前面检测的下降沿可能是噪声导致，电路就会忽略前面的数据，重新开始捕捉下降沿</p>
</li>
<li>
<p>如果通过了起始位侦测，那么接收状态将由空闲变为接收起始位。同时第 8、9、10 次采样的位置就正好是起始位的正中间，之后接收数据位时也都在第 8、9、10 位进行采样</p>
</li>
</ul>
<h3 id="数据采样">数据采样</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\USART_7.png" alt=""></p>
<p>1 ~ 16 是一个数据位的时间长度，在一个数据为总共有 16 个采样时钟</p>
<p>由于起始位已经对齐了采样时钟，这里就直接在 8、9、10 次采样数据位。为了保证数据的可靠性，这里是连续采样 3 次。此处检测噪声规则与前面起始位噪声检测一致为 2：1 且如果有噪声会置 NE 标志位</p>
<h3 id="波特率发生器">波特率发生器</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\USART_8.png" alt=""></p>
<ul>
<li>
<p>发送器和接收器的波特率由波特率寄存器 BRR 里的 DIV 决定</p>
</li>
<li>
<p>计算公式：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>波特率</mtext><mo>=</mo><mi>f</mi><mi>P</mi><mi>C</mi><mi>L</mi><mi>K</mi><mn>2</mn><mi mathvariant="normal">/</mi><mn>1</mn><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mn>16</mn><mo>∗</mo><mi>D</mi><mi>I</mi><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">波特率 = fPCLK2/1 / (16 * DIV )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">波特率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.07153em;">PC</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord">2/1/</span><span class="mopen">(</span><span class="mord">16</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span></p>
<p>例：要配置 USART 波特率为 9600。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>9600</mn><mo>=</mo><mn>72</mn><mi>M</mi><mi>H</mi><mi>z</mi><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mn>16</mn><mo>∗</mo><mi>D</mi><mi>I</mi><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">9600 = 72MHz / (16 * DIV)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">9600</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">72</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal" style="margin-right:0.04398em;">Hz</span><span class="mord">/</span><span class="mopen">(</span><span class="mord">16</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>I</mi><mi>V</mi><mo>=</mo><mn>468.75</mn></mrow><annotation encoding="application/x-tex">DIV = 468.75</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">468.75</span></span></span></span>。将十进制数转为二进制得 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>111010100.11</mn></mrow><annotation encoding="application/x-tex">111010100.11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">111010100.11</span></span></span></span>，则写入寄存器中：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>I</mi><msub><mi>V</mi><mi>M</mi></msub><mi>a</mi><mi>n</mi><mi>t</mi><mi>i</mi><mi>s</mi><mi>s</mi><mi>a</mi><mo>=</mo><mn>000111010100</mn></mrow><annotation encoding="application/x-tex">DIV_Mantissa = 000111010100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">an</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ss</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">000111010100</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>I</mi><msub><mi>V</mi><mi>F</mi></msub><mi>r</mi><mi>a</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>=</mo><mn>1100</mn></mrow><annotation encoding="application/x-tex">DIV_Fraction = 1100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1100</span></span></span></span></p>
</li>
</ul>
<h3 id="实操-7">实操</h3>
<p>使用串口发送数据到电脑：</p>
<ol>
<li>RCC 开启 USART 和 GPIO 时钟</li>
<li>GPIO 初始化，TX 配置为复用输出，RX 配置为输入</li>
<li>配置 USART（如果需要接收的功能还需要配置中断（ITConfig、NVIC））</li>
<li>开关控制使能 USART</li>
</ol>
<h2 id="usart-串口数据包">USART 串口数据包</h2>
<h3 id="数据包概念">数据包概念</h3>
<p>定义包头、包尾，将数据包裹起来</p>
<p>数据包一般分为：<strong>固定包长，含包头包尾</strong>、<strong>可变包长，含包头包尾</strong></p>
<h3 id="状态机思想">状态机思想</h3>
<ul>
<li>
<p>能够记住不同状态的机制，在不同状态执行不同的操作，同时还要进行状态的合理转移</p>
</li>
<li>
<p>其中每个阶段使用一个变量去表示</p>
</li>
<li>
<p><strong>固定包长</strong>：
<img src="file:///d:\Project\STM32\.Notes\IMG\USART_9.png" alt=""></p>
</li>
<li>
<p><strong>可变包长</strong>：
<img src="file:///d:\Project\STM32\.Notes\IMG\USART_10.png" alt=""></p>
</li>
</ul>
<h2 id="i2c-通信协议">I2C 通信协议</h2>
<h3 id="简介-4">简介</h3>
<ul>
<li>
<p>I2C 总线（Inter IC BUS）是一种通用数据总线</p>
</li>
<li>
<p>两根通信线：SCL（Serial Clock）、SDA（Serial Data）</p>
</li>
<li>
<p>同步，半双工</p>
</li>
<li>
<p>带数据应答</p>
</li>
<li>
<p>支持总线挂载多设备（一主多从、多主多从）</p>
</li>
</ul>
<h3 id="硬件电路-2">硬件电路</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\I2C_0.png" alt=""></p>
<p><em>I2C 经典电路模型</em></p>
<p>这是一个一主多从的模型，左边 CPU 作为总线的主机。</p>
<p><strong>CPU</strong>：主机的权力很大，包括：对 SCL 线的完全控制、在空闲状态下主机可以主动对 SDA 的控制，只有在从机发送数据和从机应答的时候 SDA 控制权才会转交给从机</p>
<p><strong>被控 IC</strong>：挂载在 I2C 总线上的从机，可以是任意的使用 I2C 通信协议的传感器、OLED、存储器、时钟模块等。从机的权利比较小，对于 SCL 时钟线，在任何时候都只能被动的读取，不允许控制 SCL 线。对于 SDA 数据线，从机不允许主动发起对 SDA 的控制，只有主机发送读取从机的命令或者从机应答的时候，从机才能短暂的取得 SDA 的控制权</p>
<ul>
<li>所有 I2C 设备的 SCL 连在一起，SDA 连在一起</li>
</ul>
<p>为了避免因总线没协调好导致电源短路的问题，I2C 协议规定禁止所有设备输出强上拉的高电平，采用外置弱上拉电阻加开漏输出的电路结构</p>
<ul>
<li>
<p>设备的 SCL 和 SDA 均要配置成开漏输出模式</p>
</li>
<li>
<p>SCL 和 SDA 各添加一个上拉电阻，阻值一般为 4.7KΩ 左右</p>
</li>
</ul>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\I2C_1.png" alt=""></p>
<p><em>内部电路</em></p>
<p>左边为 SCL（SCLK 就是 SCL）</p>
<p>右边为 SDA（DATA 就是 SDA）</p>
<p><strong>输入</strong>：信号从 SCLK 引脚进入，都可以通过一个数据缓冲器或者是施密特触发器进行输入（SCLK IN）。因为输入对电路没有任何影响，任何设备在任何时刻都是可以输入的</p>
<p><strong>输出</strong>：因为采用的是开漏输出配置，所以只有强下拉（低电平）、浮空（高电平）。这样所有的设备都只能输出低电平而不能输出高电平。为了避免浮空产生的不稳定性，就需要在总线外 SCL 和 SDA 各外置一个上拉电阻，从而弱上拉到高电平</p>
<ol>
<li>完全杜绝了电源短路现象，保证电路安全。电路无论何时都不会处于一个被同时强拉和强推的状态</li>
<li>避免了引脚模式的频繁切换。开漏 + 弱上拉的模式，同时兼具了输入和输出的功能</li>
<li>该模式会有一个<code>线与</code>（与门）的现象。只要有任意一个或多个设备输出了低电平，总线就处于低电平，只有所有设备都输出高电平，总线才会处于高电平。I2C 可以利用这个特性执行多主机模式下的时钟同步和总线仲裁</li>
</ol>
<h3 id="i2c-时序基本单元">I2C 时序基本单元</h3>
<p><strong>起始条件和终止条件都是由主机产生的，从机必须保持浮空，否则就是多主机模型</strong></p>
<ul>
<li>
<p>起始条件：SCL 高电平期间，SDA 从高电平切换到低电平</p>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\I2C_2.png" alt=""></p>
</li>
<li>
<p>终止条件：SCL 高电平期间，SDA 从低电平切换到高电平</p>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\I2C_3.png" alt=""></p>
</li>
<li>
<p><strong>发送</strong>一个字节：SCL 低电平期间，<strong>主机</strong>将数据位（0 / 1）依次放到 SDA 线上（<strong>高位先行</strong>），然后释放 SCL，<strong>从机</strong>将 SCL 高电平期间读取数据为，所以 SCL 高电平期间 SDA 不允许有数据变化，依次循环上述过程 8 次，即可<strong>发送</strong>一个字节</p>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\I2C_4.png" alt=""></p>
</li>
<li>
<p><strong>接收</strong>一个字节：SCL 低电平期间，<strong>从机</strong>将数据位（0 / 1）依次放到 SDA 线上（<strong>高位先行</strong>），然后释放 SCL，<strong>主机</strong>将 SCL 高电平期间读取数据为，所以 SCL 高电平期间 SDA 不允许有数据变化，依次循环上述过程 8 次，即可<strong>接收</strong>一个字节（主机在接收之前，需要释放 SDA。相当于切换成输入模式）</p>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\I2C_5.png" alt=""></p>
</li>
<li>
<p>接收应答：主机在发送完一个字节之后，在下一个时钟接收一位数据，判断从机是否应答，数据 0 表示应答，数据 1 表示非应答（主机在接收之前，需要释放 SDA）。</p>
<p>每发送一个字节就要紧跟着调用接收应答的时序，用来判断从机有没有收到刚才给它的数据。如果从机收到：在应答位这里，主机释放 SDA 的时候，从机就应该立刻把 SDA 拉下来，然后在 SCL 高电平期间，主机读取应答位。如果应答位为 0，就说明从机确实收到了</p>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\I2C_7.png" alt=""></p>
</li>
<li>
<p>发送应答：主机在接受完一个字节之后，再下一个时钟发送一位数据，数据 0 表示应答，数据 1 表示非应答。也就是告诉从机，收到数据可以继续发送。如果主机没应答，从机就会释放 SDA，将 SDA 控制权交回主机</p>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\I2C_6.png" alt=""></p>
</li>
</ul>
<p><strong>两者时序分别和发送一个字节、接收一个字节的其中一位相同，可理解成发送一位和接收一位</strong></p>
<h3 id="i2c-时序">I2C 时序</h3>
<ul>
<li>
<p><strong><code>指定</code>地址<code>写</code></strong>：通过从机地址（Slave Address）来确定指定设备，并且对于该指定的设备在其内部的寄存器指定地址（Reg Address）下，写入指定的数据（Data）</p>
<ol>
<li>
<p>指定设备：</p>
<p>起始位：SDA 拉低，SCL 高电平，实现 SCL 高电平期间 SDA 下降沿
数据位：写入 7 位从机地址 + 1 位读写位（0 为写，1 为读）
应答位：主机释放 SDA（低变高电平）的瞬间被从机拉低（产生应答），主机在 SCL 高电平读取 SDA，如果低电平则说明从机接收到数据</p>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\I2C_8.png" alt=""></p>
</li>
<li>
<p>指定地址：</p>
<p>主机以高位优先写入数据<code>0x19</code>，在 MPU6050 处为指定寄存器的地址</p>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\I2C_8_1.png" alt=""></p>
</li>
<li>
<p>指定数据</p>
<p>主机以高位优先写入数据<code>0xAA</code>，在上一发送的字节指定的寄存器中写入指定的值 0xAA
停止位：主机先拉低 SDA，然后释放 SCL，在 SCL 高电平期间 SDA 的上升沿</p>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\I2C_8_2.png" alt=""></p>
</li>
</ol>
<ul>
<li>则这个数据帧的目的就是：对于指定从机地址为 110100 的设备进行 0 写入值为 0xAA 到其地址为 0x19 的寄存器中的操作</li>
</ul>
</li>
<li>
<p><strong><code>当前</code>地址<code>读</code></strong>：通过从机地址（Slave Address）来确定指定设备，并且对于该指定的设备在<strong>当前地址指针</strong>指示的地址下，读取从机的数据（Data）</p>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\I2C_9.png" alt=""></p>
<ol>
<li>
<p>指定设备</p>
<p>与当前地址写的指定设备一致，都是决定从机。不同的是读写位此次置 1（表示接下来执行<strong>读</strong>操作）</p>
</li>
<li>
<p>当前地址指针</p>
<p>从机中，所有的寄存器被分配到了一个线性区域中，且拥有以后个独立的指针变量指示着其中的一个寄存器（该指针上电一般默认指向 0 地址），且每写入和读出一个字节后都会自动自增一次，移动到下一个位置。当主机执行当前地址读的操作时，从机就会将该指针指向的寄存器中的值返回发送给主机。</p>
<p>假设在指定地址写的时序中在 0x19 的位置写入了 0xAA，则这个指针就会从指向<code>0x19 + 1</code>的位置——<code>0x1A</code>。当再次调用当前地址读的时序，返回的就是<code>0x1A</code>地址下的值，再调用一次就是<code>0x1B</code>的值</p>
</li>
</ol>
<p><strong>*由于当前地址读并不能指定读的地址，所以该时序用的并不多</strong></p>
</li>
<li>
<p><strong><code>指定</code>地址<code>读</code></strong>：通过从机地址（Slave Address）来确定指定设备，并且对于该指定的设备在其内部的寄存器指定地址（Reg Address）下，读取指定的数据（Data）</p>
<p><strong>其实就是用<code>指定地址写</code>来将指针指向到要读寄存器地址，然后另起一个时序再使用<code>当前地址读</code>的时序去读指定地址</strong></p>
<p>一般也将指定地址读称作复合格式（官方规定该格式是一整个数据帧，也就是：起始 -&gt; 重复起始 -&gt; 停止）</p>
<p>如图，左边时序为指定地址写的指定设备、指定地址。右边时序为当前地址读</p>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\I2C_10.png" alt=""></p>
<hr>
<p><em>从指定地址写到当前地址读的切换时序图</em></p>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\I2C_11.png" alt=""></p>
<p>前面指定地址写确定了后面要读的地址为 0x19，<strong>但不进行数据写入，因此不会触发指针自增</strong>。而是再来个起始条件 Sr（Start Repeat）也就是重复起始条件，相当于另起一个时序</p>
<p>新的起始条件后重新寻址找到从机并且置读写位为读，接着主机接收一个字节，该值就是 0x19 地址下的数据</p>
</li>
</ul>
<p><strong>发送/接收多个字节</strong>：在指定地址后可以重复发送多个字节或读取多次值，且值会分别写入/读取不同寄存器中 <strong>（因为读写寄存器后会自增地址）</strong></p>
<ul>
<li>例：指定地址为 0x19，指定数据为 0xAA、0xAB、0x44，则 0xAA 写入 0x19，0xAB 写入 0x1A，0x44 写入 0x1B，...以此类推</li>
</ul>
<p><strong>只读一个/读到最后一个字节</strong>：如果只想读一个字节或是读取的字节足够了，需要在主机给从机的应答位中发送非应答 1（SA：Send ACK）也就是该主机应答时不去拉低 SDA，从机读到 SCL 高电平时 SDA 也为高电平，则表示主机没有应答，从机释放总线，交出 SDA 控制权。如果主机应答，则从机会继续发送下一个数据，此时 SDA 会因为被从机控制，无法正常弹回高电平。</p>
<h2 id="spi-通信协议">SPI 通信协议</h2>
<h3 id="spi-通信">SPI 通信</h3>
<ul>
<li>
<p>四根通信线：</p>
<ul>
<li>
<p>SCK/SCLK/CLK/CK：串行时钟线</p>
</li>
<li>
<p>MOSI/DO：主机 M 输出 O、从机 S 输入 I</p>
</li>
<li>
<p>MISO/DI：主机 M 输入 I、从机 S 输出 O</p>
</li>
<li>
<p>SS/NSS/CS：从机选择。为低电平则选中从机，<strong>低电平有效</strong></p>
</li>
</ul>
</li>
</ul>
<p>SPI 相比 I2C，少了应答机制</p>
<h3 id="硬件电路-3">硬件电路</h3>
<ul>
<li>
<p>主机的 MOSI、SCK 均输出，从机的 MISO 均输出，三根线所有 SPI 设备都要连接</p>
</li>
<li>
<p>主机发出 SS 连接对应从机</p>
</li>
<li>
<p>主机输出引脚配置为推挽输出，输入引脚配置为浮空或上拉输入</p>
</li>
</ul>
<p><strong>MISO 冲突问题：</strong></p>
<p>SPI 唯一可能冲突的地方让你找着了，但是 SPI 协议有一条规定：</p>
<p>当从机的 SS 引脚为高电平(从机未被选中时)，它的 MISO 引脚必须切换为高阻态模式</p>
<h3 id="移位示意图">移位示意图</h3>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\SPI_0.png" alt=""></p>
<ul>
<li>
<p>上升沿：</p>
<p>波特率发生器每产生一次<strong>上升沿</strong>，移位寄存器就向左移动一位数据</p>
<p>主机数据从 MOSI 输出，从机从 MOSI 接收，并置于从机移位寄存器右边</p>
<p>从机数据类似，由 MISO 进行通信</p>
</li>
<li>
<p>下降沿：</p>
<p>当波特率产生<strong>下降沿</strong>时，主机和从机都会进行数据采样输入</p>
<p>主机会采样 MISO 的电平，从机会采样 MOSI 的电平，并分别加入各自移位寄存器的最低位</p>
</li>
</ul>
<h3 id="spi-时序基本单元">SPI 时序基本单元</h3>
<ul>
<li>
<p>起始条件：SS 从高电平切换到低电平</p>
</li>
<li>
<p>终止条件：SS 从低电平切换到高电平</p>
</li>
</ul>
<p>SPI 共有 4 中模式，本质就是针对 SS 在空闲时的电平与时钟上升下降沿采样或发送数据进行选择 <em>(可能是为了适应更多的模块而做出的妥协？为什么是协议妥协芯片，不太明白)</em></p>
<p>此处仅对模式 1 进行讨论</p>
<ul>
<li>
<p>交换一个字节(模式 1)</p>
</li>
<li>
<p>CPOL=0 <em>(时钟极性)</em>：空闲状态时，SCK 为低电平</p>
</li>
<li>
<p>CPHA=1 <em>(时钟相位)</em>：SCK 第一个边沿移出数据，第二个边沿移入数据</p>
</li>
</ul>
<p><img src="file:///d:\Project\STM32\.Notes\IMG\SPI_1.png" alt=""></p>
<p>如果一个时序完成，但主机还想在同一个从机上发送或接收数据，则不用置 SS 高电平，继续发送时序即可</p>
<p><strong>与 I2C 时序不同之处：</strong></p>
<p>I2C 规定第一个有效数据流 <em>(大概是已经确认从机地址后的数据流)</em> 对应字节是寄存器地址，之后才是读写的数据。这样的模型也被称为读写寄存器模型</p>
<p>而SPI通常采用指令码加读写数据的模型</p>

            <script async src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
            
        </body>
        </html>